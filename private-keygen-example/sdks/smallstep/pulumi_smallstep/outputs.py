# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'AccountBrowser',
    'AccountEthernet',
    'AccountVpn',
    'AccountVpnIke',
    'AccountWifi',
    'AuthorityIntermediateIssuer',
    'AuthorityIntermediateIssuerNameConstraints',
    'AuthorityIntermediateIssuerSubject',
    'AuthorityRootIssuer',
    'AuthorityRootIssuerNameConstraints',
    'AuthorityRootIssuerSubject',
    'DeviceCollectionAccountCertificateData',
    'DeviceCollectionAccountCertificateDataCommonName',
    'DeviceCollectionAccountCertificateDataCountry',
    'DeviceCollectionAccountCertificateDataLocality',
    'DeviceCollectionAccountCertificateDataOrganization',
    'DeviceCollectionAccountCertificateDataOrganizationalUnit',
    'DeviceCollectionAccountCertificateDataPostalCode',
    'DeviceCollectionAccountCertificateDataProvince',
    'DeviceCollectionAccountCertificateDataSans',
    'DeviceCollectionAccountCertificateDataStreetAddress',
    'DeviceCollectionAccountCertificateInfo',
    'DeviceCollectionAccountKeyInfo',
    'DeviceCollectionAccountReloadInfo',
    'DeviceCollectionAwsVm',
    'DeviceCollectionAzureVm',
    'DeviceCollectionGcpVm',
    'DeviceCollectionTpm',
    'ProvisionerAcme',
    'ProvisionerAcmeAttestation',
    'ProvisionerAws',
    'ProvisionerAzure',
    'ProvisionerClaims',
    'ProvisionerGcp',
    'ProvisionerJwk',
    'ProvisionerOidc',
    'ProvisionerOptions',
    'ProvisionerOptionsSsh',
    'ProvisionerOptionsX509',
    'ProvisionerWebhookBasicAuth',
    'ProvisionerX5c',
    'WorkloadCertificateData',
    'WorkloadCertificateDataCommonName',
    'WorkloadCertificateDataCountry',
    'WorkloadCertificateDataLocality',
    'WorkloadCertificateDataOrganization',
    'WorkloadCertificateDataOrganizationalUnit',
    'WorkloadCertificateDataPostalCode',
    'WorkloadCertificateDataProvince',
    'WorkloadCertificateDataSans',
    'WorkloadCertificateDataStreetAddress',
    'WorkloadCertificateInfo',
    'WorkloadHooks',
    'WorkloadHooksRenew',
    'WorkloadHooksSign',
    'WorkloadKeyInfo',
    'WorkloadReloadInfo',
    'GetAccountBrowserResult',
    'GetAccountEthernetResult',
    'GetAccountVpnResult',
    'GetAccountVpnIkeResult',
    'GetAccountWifiResult',
    'GetDeviceCollectionAccountCertificateDataResult',
    'GetDeviceCollectionAccountCertificateDataCommonNameResult',
    'GetDeviceCollectionAccountCertificateDataCountryResult',
    'GetDeviceCollectionAccountCertificateDataLocalityResult',
    'GetDeviceCollectionAccountCertificateDataOrganizationResult',
    'GetDeviceCollectionAccountCertificateDataOrganizationalUnitResult',
    'GetDeviceCollectionAccountCertificateDataPostalCodeResult',
    'GetDeviceCollectionAccountCertificateDataProvinceResult',
    'GetDeviceCollectionAccountCertificateDataSansResult',
    'GetDeviceCollectionAccountCertificateDataStreetAddressResult',
    'GetDeviceCollectionAccountCertificateInfoResult',
    'GetDeviceCollectionAccountKeyInfoResult',
    'GetDeviceCollectionAccountReloadInfoResult',
    'GetProvisionerAcmeResult',
    'GetProvisionerAcmeAttestationResult',
    'GetProvisionerAwsResult',
    'GetProvisionerAzureResult',
    'GetProvisionerClaimsResult',
    'GetProvisionerGcpResult',
    'GetProvisionerJwkResult',
    'GetProvisionerOidcResult',
    'GetProvisionerOptionsResult',
    'GetProvisionerOptionsSshResult',
    'GetProvisionerOptionsX509Result',
    'GetProvisionerX5cResult',
]

@pulumi.output_type
class AccountBrowser(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class AccountEthernet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caChain":
            suggest = "ca_chain"
        elif key == "externalRadiusServer":
            suggest = "external_radius_server"
        elif key == "networkAccessServerIp":
            suggest = "network_access_server_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountEthernet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountEthernet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountEthernet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autojoin: Optional[bool] = None,
                 ca_chain: Optional[str] = None,
                 external_radius_server: Optional[bool] = None,
                 network_access_server_ip: Optional[str] = None):
        if autojoin is not None:
            pulumi.set(__self__, "autojoin", autojoin)
        if ca_chain is not None:
            pulumi.set(__self__, "ca_chain", ca_chain)
        if external_radius_server is not None:
            pulumi.set(__self__, "external_radius_server", external_radius_server)
        if network_access_server_ip is not None:
            pulumi.set(__self__, "network_access_server_ip", network_access_server_ip)

    @property
    @pulumi.getter
    def autojoin(self) -> Optional[bool]:
        return pulumi.get(self, "autojoin")

    @property
    @pulumi.getter(name="caChain")
    def ca_chain(self) -> Optional[str]:
        return pulumi.get(self, "ca_chain")

    @property
    @pulumi.getter(name="externalRadiusServer")
    def external_radius_server(self) -> Optional[bool]:
        return pulumi.get(self, "external_radius_server")

    @property
    @pulumi.getter(name="networkAccessServerIp")
    def network_access_server_ip(self) -> Optional[str]:
        return pulumi.get(self, "network_access_server_ip")


@pulumi.output_type
class AccountVpn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionType":
            suggest = "connection_type"
        elif key == "remoteAddress":
            suggest = "remote_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountVpn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountVpn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountVpn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_type: str,
                 remote_address: str,
                 autojoin: Optional[bool] = None,
                 ike: Optional['outputs.AccountVpnIke'] = None,
                 vendor: Optional[str] = None):
        """
        :param str connection_type: Allowed values: `IPSec` `IKEv2` `SSL`
        :param str vendor: Allowed values: `F5` `Cisco` `Juniper`
        """
        pulumi.set(__self__, "connection_type", connection_type)
        pulumi.set(__self__, "remote_address", remote_address)
        if autojoin is not None:
            pulumi.set(__self__, "autojoin", autojoin)
        if ike is not None:
            pulumi.set(__self__, "ike", ike)
        if vendor is not None:
            pulumi.set(__self__, "vendor", vendor)

    @property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> str:
        """
        Allowed values: `IPSec` `IKEv2` `SSL`
        """
        return pulumi.get(self, "connection_type")

    @property
    @pulumi.getter(name="remoteAddress")
    def remote_address(self) -> str:
        return pulumi.get(self, "remote_address")

    @property
    @pulumi.getter
    def autojoin(self) -> Optional[bool]:
        return pulumi.get(self, "autojoin")

    @property
    @pulumi.getter
    def ike(self) -> Optional['outputs.AccountVpnIke']:
        return pulumi.get(self, "ike")

    @property
    @pulumi.getter
    def vendor(self) -> Optional[str]:
        """
        Allowed values: `F5` `Cisco` `Juniper`
        """
        return pulumi.get(self, "vendor")


@pulumi.output_type
class AccountVpnIke(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caChain":
            suggest = "ca_chain"
        elif key == "remoteId":
            suggest = "remote_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountVpnIke. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountVpnIke.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountVpnIke.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_chain: Optional[str] = None,
                 eap: Optional[bool] = None,
                 remote_id: Optional[str] = None):
        """
        :param str remote_id: Typically, the common name of the remote server. Defaults to the remote address.
        """
        if ca_chain is not None:
            pulumi.set(__self__, "ca_chain", ca_chain)
        if eap is not None:
            pulumi.set(__self__, "eap", eap)
        if remote_id is not None:
            pulumi.set(__self__, "remote_id", remote_id)

    @property
    @pulumi.getter(name="caChain")
    def ca_chain(self) -> Optional[str]:
        return pulumi.get(self, "ca_chain")

    @property
    @pulumi.getter
    def eap(self) -> Optional[bool]:
        return pulumi.get(self, "eap")

    @property
    @pulumi.getter(name="remoteId")
    def remote_id(self) -> Optional[str]:
        """
        Typically, the common name of the remote server. Defaults to the remote address.
        """
        return pulumi.get(self, "remote_id")


@pulumi.output_type
class AccountWifi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caChain":
            suggest = "ca_chain"
        elif key == "externalRadiusServer":
            suggest = "external_radius_server"
        elif key == "networkAccessServerIp":
            suggest = "network_access_server_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountWifi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountWifi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountWifi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ssid: str,
                 autojoin: Optional[bool] = None,
                 ca_chain: Optional[str] = None,
                 external_radius_server: Optional[bool] = None,
                 hidden: Optional[bool] = None,
                 network_access_server_ip: Optional[str] = None):
        pulumi.set(__self__, "ssid", ssid)
        if autojoin is not None:
            pulumi.set(__self__, "autojoin", autojoin)
        if ca_chain is not None:
            pulumi.set(__self__, "ca_chain", ca_chain)
        if external_radius_server is not None:
            pulumi.set(__self__, "external_radius_server", external_radius_server)
        if hidden is not None:
            pulumi.set(__self__, "hidden", hidden)
        if network_access_server_ip is not None:
            pulumi.set(__self__, "network_access_server_ip", network_access_server_ip)

    @property
    @pulumi.getter
    def ssid(self) -> str:
        return pulumi.get(self, "ssid")

    @property
    @pulumi.getter
    def autojoin(self) -> Optional[bool]:
        return pulumi.get(self, "autojoin")

    @property
    @pulumi.getter(name="caChain")
    def ca_chain(self) -> Optional[str]:
        return pulumi.get(self, "ca_chain")

    @property
    @pulumi.getter(name="externalRadiusServer")
    def external_radius_server(self) -> Optional[bool]:
        return pulumi.get(self, "external_radius_server")

    @property
    @pulumi.getter
    def hidden(self) -> Optional[bool]:
        return pulumi.get(self, "hidden")

    @property
    @pulumi.getter(name="networkAccessServerIp")
    def network_access_server_ip(self) -> Optional[str]:
        return pulumi.get(self, "network_access_server_ip")


@pulumi.output_type
class AuthorityIntermediateIssuer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVersion":
            suggest = "key_version"
        elif key == "maxPathLength":
            suggest = "max_path_length"
        elif key == "nameConstraints":
            suggest = "name_constraints"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthorityIntermediateIssuer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthorityIntermediateIssuer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthorityIntermediateIssuer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_version: str,
                 name: str,
                 duration: Optional[str] = None,
                 max_path_length: Optional[float] = None,
                 name_constraints: Optional['outputs.AuthorityIntermediateIssuerNameConstraints'] = None,
                 subject: Optional['outputs.AuthorityIntermediateIssuerSubject'] = None):
        """
        :param str key_version: The signature algorithm.
                Allowed values: `EC_SIGN_P256_SHA256` `EC_SIGN_P384_SHA384` `RSA_SIGN_PKCS1_2048_SHA256` `RSA_SIGN_PKCS1_3072_SHA256` `RSA_SIGN_PKCS1_4096_SHA256` `RSA_SIGN_PKCS1_4096_SHA512` `RSA_SIGN_PSS_2048_SHA256` `RSA_SIGN_PSS_3072_SHA256` `RSA_SIGN_PSS_4096_SHA256` `RSA_SIGN_PSS_4096_SHA512`
        :param str name: The name of the issuer.
        :param str duration: The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param 'AuthorityIntermediateIssuerNameConstraintsArgs' name_constraints: X509 certificate name constraints.
        :param 'AuthorityIntermediateIssuerSubjectArgs' subject: Name used in x509 certificates
        """
        pulumi.set(__self__, "key_version", key_version)
        pulumi.set(__self__, "name", name)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if max_path_length is not None:
            pulumi.set(__self__, "max_path_length", max_path_length)
        if name_constraints is not None:
            pulumi.set(__self__, "name_constraints", name_constraints)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter(name="keyVersion")
    def key_version(self) -> str:
        """
        The signature algorithm.
         Allowed values: `EC_SIGN_P256_SHA256` `EC_SIGN_P384_SHA384` `RSA_SIGN_PKCS1_2048_SHA256` `RSA_SIGN_PKCS1_3072_SHA256` `RSA_SIGN_PKCS1_4096_SHA256` `RSA_SIGN_PKCS1_4096_SHA512` `RSA_SIGN_PSS_2048_SHA256` `RSA_SIGN_PSS_3072_SHA256` `RSA_SIGN_PSS_4096_SHA256` `RSA_SIGN_PSS_4096_SHA512`
        """
        return pulumi.get(self, "key_version")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the issuer.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def duration(self) -> Optional[str]:
        """
        The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="maxPathLength")
    def max_path_length(self) -> Optional[float]:
        return pulumi.get(self, "max_path_length")

    @property
    @pulumi.getter(name="nameConstraints")
    def name_constraints(self) -> Optional['outputs.AuthorityIntermediateIssuerNameConstraints']:
        """
        X509 certificate name constraints.
        """
        return pulumi.get(self, "name_constraints")

    @property
    @pulumi.getter
    def subject(self) -> Optional['outputs.AuthorityIntermediateIssuerSubject']:
        """
        Name used in x509 certificates
        """
        return pulumi.get(self, "subject")


@pulumi.output_type
class AuthorityIntermediateIssuerNameConstraints(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedDnsDomains":
            suggest = "excluded_dns_domains"
        elif key == "excludedEmailAddresses":
            suggest = "excluded_email_addresses"
        elif key == "excludedIpRanges":
            suggest = "excluded_ip_ranges"
        elif key == "excludedUriDomains":
            suggest = "excluded_uri_domains"
        elif key == "permittedDnsDomains":
            suggest = "permitted_dns_domains"
        elif key == "permittedEmailAddresses":
            suggest = "permitted_email_addresses"
        elif key == "permittedIpRanges":
            suggest = "permitted_ip_ranges"
        elif key == "permittedUriDomains":
            suggest = "permitted_uri_domains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthorityIntermediateIssuerNameConstraints. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthorityIntermediateIssuerNameConstraints.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthorityIntermediateIssuerNameConstraints.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 critical: Optional[bool] = None,
                 excluded_dns_domains: Optional[Sequence[str]] = None,
                 excluded_email_addresses: Optional[Sequence[str]] = None,
                 excluded_ip_ranges: Optional[Sequence[str]] = None,
                 excluded_uri_domains: Optional[Sequence[str]] = None,
                 permitted_dns_domains: Optional[Sequence[str]] = None,
                 permitted_email_addresses: Optional[Sequence[str]] = None,
                 permitted_ip_ranges: Optional[Sequence[str]] = None,
                 permitted_uri_domains: Optional[Sequence[str]] = None):
        """
        :param bool critical: Whether or not name constraints are marked critical.
        """
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if excluded_dns_domains is not None:
            pulumi.set(__self__, "excluded_dns_domains", excluded_dns_domains)
        if excluded_email_addresses is not None:
            pulumi.set(__self__, "excluded_email_addresses", excluded_email_addresses)
        if excluded_ip_ranges is not None:
            pulumi.set(__self__, "excluded_ip_ranges", excluded_ip_ranges)
        if excluded_uri_domains is not None:
            pulumi.set(__self__, "excluded_uri_domains", excluded_uri_domains)
        if permitted_dns_domains is not None:
            pulumi.set(__self__, "permitted_dns_domains", permitted_dns_domains)
        if permitted_email_addresses is not None:
            pulumi.set(__self__, "permitted_email_addresses", permitted_email_addresses)
        if permitted_ip_ranges is not None:
            pulumi.set(__self__, "permitted_ip_ranges", permitted_ip_ranges)
        if permitted_uri_domains is not None:
            pulumi.set(__self__, "permitted_uri_domains", permitted_uri_domains)

    @property
    @pulumi.getter
    def critical(self) -> Optional[bool]:
        """
        Whether or not name constraints are marked critical.
        """
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter(name="excludedDnsDomains")
    def excluded_dns_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_dns_domains")

    @property
    @pulumi.getter(name="excludedEmailAddresses")
    def excluded_email_addresses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_email_addresses")

    @property
    @pulumi.getter(name="excludedIpRanges")
    def excluded_ip_ranges(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_ip_ranges")

    @property
    @pulumi.getter(name="excludedUriDomains")
    def excluded_uri_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_uri_domains")

    @property
    @pulumi.getter(name="permittedDnsDomains")
    def permitted_dns_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "permitted_dns_domains")

    @property
    @pulumi.getter(name="permittedEmailAddresses")
    def permitted_email_addresses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "permitted_email_addresses")

    @property
    @pulumi.getter(name="permittedIpRanges")
    def permitted_ip_ranges(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "permitted_ip_ranges")

    @property
    @pulumi.getter(name="permittedUriDomains")
    def permitted_uri_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "permitted_uri_domains")


@pulumi.output_type
class AuthorityIntermediateIssuerSubject(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commonName":
            suggest = "common_name"
        elif key == "emailAddress":
            suggest = "email_address"
        elif key == "organizationalUnit":
            suggest = "organizational_unit"
        elif key == "postalCode":
            suggest = "postal_code"
        elif key == "serialNumber":
            suggest = "serial_number"
        elif key == "streetAddress":
            suggest = "street_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthorityIntermediateIssuerSubject. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthorityIntermediateIssuerSubject.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthorityIntermediateIssuerSubject.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 common_name: Optional[str] = None,
                 country: Optional[str] = None,
                 email_address: Optional[str] = None,
                 locality: Optional[str] = None,
                 organization: Optional[str] = None,
                 organizational_unit: Optional[str] = None,
                 postal_code: Optional[str] = None,
                 province: Optional[str] = None,
                 serial_number: Optional[str] = None,
                 street_address: Optional[str] = None):
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if email_address is not None:
            pulumi.set(__self__, "email_address", email_address)
        if locality is not None:
            pulumi.set(__self__, "locality", locality)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if organizational_unit is not None:
            pulumi.set(__self__, "organizational_unit", organizational_unit)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if province is not None:
            pulumi.set(__self__, "province", province)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)
        if street_address is not None:
            pulumi.set(__self__, "street_address", street_address)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[str]:
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter
    def country(self) -> Optional[str]:
        return pulumi.get(self, "country")

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> Optional[str]:
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter
    def locality(self) -> Optional[str]:
        return pulumi.get(self, "locality")

    @property
    @pulumi.getter
    def organization(self) -> Optional[str]:
        return pulumi.get(self, "organization")

    @property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> Optional[str]:
        return pulumi.get(self, "organizational_unit")

    @property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional[str]:
        return pulumi.get(self, "postal_code")

    @property
    @pulumi.getter
    def province(self) -> Optional[str]:
        return pulumi.get(self, "province")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[str]:
        return pulumi.get(self, "serial_number")

    @property
    @pulumi.getter(name="streetAddress")
    def street_address(self) -> Optional[str]:
        return pulumi.get(self, "street_address")


@pulumi.output_type
class AuthorityRootIssuer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVersion":
            suggest = "key_version"
        elif key == "maxPathLength":
            suggest = "max_path_length"
        elif key == "nameConstraints":
            suggest = "name_constraints"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthorityRootIssuer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthorityRootIssuer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthorityRootIssuer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_version: str,
                 name: str,
                 duration: Optional[str] = None,
                 max_path_length: Optional[float] = None,
                 name_constraints: Optional['outputs.AuthorityRootIssuerNameConstraints'] = None,
                 subject: Optional['outputs.AuthorityRootIssuerSubject'] = None):
        """
        :param str key_version: The signature algorithm.
                Allowed values: `EC_SIGN_P256_SHA256` `EC_SIGN_P384_SHA384` `RSA_SIGN_PKCS1_2048_SHA256` `RSA_SIGN_PKCS1_3072_SHA256` `RSA_SIGN_PKCS1_4096_SHA256` `RSA_SIGN_PKCS1_4096_SHA512` `RSA_SIGN_PSS_2048_SHA256` `RSA_SIGN_PSS_3072_SHA256` `RSA_SIGN_PSS_4096_SHA256` `RSA_SIGN_PSS_4096_SHA512`
        :param str name: The name of the issuer.
        :param str duration: The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param 'AuthorityRootIssuerNameConstraintsArgs' name_constraints: X509 certificate name constraints.
        :param 'AuthorityRootIssuerSubjectArgs' subject: Name used in x509 certificates
        """
        pulumi.set(__self__, "key_version", key_version)
        pulumi.set(__self__, "name", name)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if max_path_length is not None:
            pulumi.set(__self__, "max_path_length", max_path_length)
        if name_constraints is not None:
            pulumi.set(__self__, "name_constraints", name_constraints)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter(name="keyVersion")
    def key_version(self) -> str:
        """
        The signature algorithm.
         Allowed values: `EC_SIGN_P256_SHA256` `EC_SIGN_P384_SHA384` `RSA_SIGN_PKCS1_2048_SHA256` `RSA_SIGN_PKCS1_3072_SHA256` `RSA_SIGN_PKCS1_4096_SHA256` `RSA_SIGN_PKCS1_4096_SHA512` `RSA_SIGN_PSS_2048_SHA256` `RSA_SIGN_PSS_3072_SHA256` `RSA_SIGN_PSS_4096_SHA256` `RSA_SIGN_PSS_4096_SHA512`
        """
        return pulumi.get(self, "key_version")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the issuer.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def duration(self) -> Optional[str]:
        """
        The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="maxPathLength")
    def max_path_length(self) -> Optional[float]:
        return pulumi.get(self, "max_path_length")

    @property
    @pulumi.getter(name="nameConstraints")
    def name_constraints(self) -> Optional['outputs.AuthorityRootIssuerNameConstraints']:
        """
        X509 certificate name constraints.
        """
        return pulumi.get(self, "name_constraints")

    @property
    @pulumi.getter
    def subject(self) -> Optional['outputs.AuthorityRootIssuerSubject']:
        """
        Name used in x509 certificates
        """
        return pulumi.get(self, "subject")


@pulumi.output_type
class AuthorityRootIssuerNameConstraints(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedDnsDomains":
            suggest = "excluded_dns_domains"
        elif key == "excludedEmailAddresses":
            suggest = "excluded_email_addresses"
        elif key == "excludedIpRanges":
            suggest = "excluded_ip_ranges"
        elif key == "excludedUriDomains":
            suggest = "excluded_uri_domains"
        elif key == "permittedDnsDomains":
            suggest = "permitted_dns_domains"
        elif key == "permittedEmailAddresses":
            suggest = "permitted_email_addresses"
        elif key == "permittedIpRanges":
            suggest = "permitted_ip_ranges"
        elif key == "permittedUriDomains":
            suggest = "permitted_uri_domains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthorityRootIssuerNameConstraints. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthorityRootIssuerNameConstraints.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthorityRootIssuerNameConstraints.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 critical: Optional[bool] = None,
                 excluded_dns_domains: Optional[Sequence[str]] = None,
                 excluded_email_addresses: Optional[Sequence[str]] = None,
                 excluded_ip_ranges: Optional[Sequence[str]] = None,
                 excluded_uri_domains: Optional[Sequence[str]] = None,
                 permitted_dns_domains: Optional[Sequence[str]] = None,
                 permitted_email_addresses: Optional[Sequence[str]] = None,
                 permitted_ip_ranges: Optional[Sequence[str]] = None,
                 permitted_uri_domains: Optional[Sequence[str]] = None):
        """
        :param bool critical: Whether or not name constraints are marked critical.
        """
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if excluded_dns_domains is not None:
            pulumi.set(__self__, "excluded_dns_domains", excluded_dns_domains)
        if excluded_email_addresses is not None:
            pulumi.set(__self__, "excluded_email_addresses", excluded_email_addresses)
        if excluded_ip_ranges is not None:
            pulumi.set(__self__, "excluded_ip_ranges", excluded_ip_ranges)
        if excluded_uri_domains is not None:
            pulumi.set(__self__, "excluded_uri_domains", excluded_uri_domains)
        if permitted_dns_domains is not None:
            pulumi.set(__self__, "permitted_dns_domains", permitted_dns_domains)
        if permitted_email_addresses is not None:
            pulumi.set(__self__, "permitted_email_addresses", permitted_email_addresses)
        if permitted_ip_ranges is not None:
            pulumi.set(__self__, "permitted_ip_ranges", permitted_ip_ranges)
        if permitted_uri_domains is not None:
            pulumi.set(__self__, "permitted_uri_domains", permitted_uri_domains)

    @property
    @pulumi.getter
    def critical(self) -> Optional[bool]:
        """
        Whether or not name constraints are marked critical.
        """
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter(name="excludedDnsDomains")
    def excluded_dns_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_dns_domains")

    @property
    @pulumi.getter(name="excludedEmailAddresses")
    def excluded_email_addresses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_email_addresses")

    @property
    @pulumi.getter(name="excludedIpRanges")
    def excluded_ip_ranges(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_ip_ranges")

    @property
    @pulumi.getter(name="excludedUriDomains")
    def excluded_uri_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_uri_domains")

    @property
    @pulumi.getter(name="permittedDnsDomains")
    def permitted_dns_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "permitted_dns_domains")

    @property
    @pulumi.getter(name="permittedEmailAddresses")
    def permitted_email_addresses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "permitted_email_addresses")

    @property
    @pulumi.getter(name="permittedIpRanges")
    def permitted_ip_ranges(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "permitted_ip_ranges")

    @property
    @pulumi.getter(name="permittedUriDomains")
    def permitted_uri_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "permitted_uri_domains")


@pulumi.output_type
class AuthorityRootIssuerSubject(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commonName":
            suggest = "common_name"
        elif key == "emailAddress":
            suggest = "email_address"
        elif key == "organizationalUnit":
            suggest = "organizational_unit"
        elif key == "postalCode":
            suggest = "postal_code"
        elif key == "serialNumber":
            suggest = "serial_number"
        elif key == "streetAddress":
            suggest = "street_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthorityRootIssuerSubject. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthorityRootIssuerSubject.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthorityRootIssuerSubject.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 common_name: Optional[str] = None,
                 country: Optional[str] = None,
                 email_address: Optional[str] = None,
                 locality: Optional[str] = None,
                 organization: Optional[str] = None,
                 organizational_unit: Optional[str] = None,
                 postal_code: Optional[str] = None,
                 province: Optional[str] = None,
                 serial_number: Optional[str] = None,
                 street_address: Optional[str] = None):
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if email_address is not None:
            pulumi.set(__self__, "email_address", email_address)
        if locality is not None:
            pulumi.set(__self__, "locality", locality)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if organizational_unit is not None:
            pulumi.set(__self__, "organizational_unit", organizational_unit)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if province is not None:
            pulumi.set(__self__, "province", province)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)
        if street_address is not None:
            pulumi.set(__self__, "street_address", street_address)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[str]:
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter
    def country(self) -> Optional[str]:
        return pulumi.get(self, "country")

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> Optional[str]:
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter
    def locality(self) -> Optional[str]:
        return pulumi.get(self, "locality")

    @property
    @pulumi.getter
    def organization(self) -> Optional[str]:
        return pulumi.get(self, "organization")

    @property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> Optional[str]:
        return pulumi.get(self, "organizational_unit")

    @property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional[str]:
        return pulumi.get(self, "postal_code")

    @property
    @pulumi.getter
    def province(self) -> Optional[str]:
        return pulumi.get(self, "province")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[str]:
        return pulumi.get(self, "serial_number")

    @property
    @pulumi.getter(name="streetAddress")
    def street_address(self) -> Optional[str]:
        return pulumi.get(self, "street_address")


@pulumi.output_type
class DeviceCollectionAccountCertificateData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commonName":
            suggest = "common_name"
        elif key == "organizationalUnit":
            suggest = "organizational_unit"
        elif key == "postalCode":
            suggest = "postal_code"
        elif key == "streetAddress":
            suggest = "street_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceCollectionAccountCertificateData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceCollectionAccountCertificateData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceCollectionAccountCertificateData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 common_name: 'outputs.DeviceCollectionAccountCertificateDataCommonName',
                 country: Optional['outputs.DeviceCollectionAccountCertificateDataCountry'] = None,
                 locality: Optional['outputs.DeviceCollectionAccountCertificateDataLocality'] = None,
                 organization: Optional['outputs.DeviceCollectionAccountCertificateDataOrganization'] = None,
                 organizational_unit: Optional['outputs.DeviceCollectionAccountCertificateDataOrganizationalUnit'] = None,
                 postal_code: Optional['outputs.DeviceCollectionAccountCertificateDataPostalCode'] = None,
                 province: Optional['outputs.DeviceCollectionAccountCertificateDataProvince'] = None,
                 sans: Optional['outputs.DeviceCollectionAccountCertificateDataSans'] = None,
                 street_address: Optional['outputs.DeviceCollectionAccountCertificateDataStreetAddress'] = None):
        pulumi.set(__self__, "common_name", common_name)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if locality is not None:
            pulumi.set(__self__, "locality", locality)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if organizational_unit is not None:
            pulumi.set(__self__, "organizational_unit", organizational_unit)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if province is not None:
            pulumi.set(__self__, "province", province)
        if sans is not None:
            pulumi.set(__self__, "sans", sans)
        if street_address is not None:
            pulumi.set(__self__, "street_address", street_address)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> 'outputs.DeviceCollectionAccountCertificateDataCommonName':
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter
    def country(self) -> Optional['outputs.DeviceCollectionAccountCertificateDataCountry']:
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def locality(self) -> Optional['outputs.DeviceCollectionAccountCertificateDataLocality']:
        return pulumi.get(self, "locality")

    @property
    @pulumi.getter
    def organization(self) -> Optional['outputs.DeviceCollectionAccountCertificateDataOrganization']:
        return pulumi.get(self, "organization")

    @property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> Optional['outputs.DeviceCollectionAccountCertificateDataOrganizationalUnit']:
        return pulumi.get(self, "organizational_unit")

    @property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional['outputs.DeviceCollectionAccountCertificateDataPostalCode']:
        return pulumi.get(self, "postal_code")

    @property
    @pulumi.getter
    def province(self) -> Optional['outputs.DeviceCollectionAccountCertificateDataProvince']:
        return pulumi.get(self, "province")

    @property
    @pulumi.getter
    def sans(self) -> Optional['outputs.DeviceCollectionAccountCertificateDataSans']:
        return pulumi.get(self, "sans")

    @property
    @pulumi.getter(name="streetAddress")
    def street_address(self) -> Optional['outputs.DeviceCollectionAccountCertificateDataStreetAddress']:
        return pulumi.get(self, "street_address")


@pulumi.output_type
class DeviceCollectionAccountCertificateDataCommonName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceMetadata":
            suggest = "device_metadata"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceCollectionAccountCertificateDataCommonName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceCollectionAccountCertificateDataCommonName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceCollectionAccountCertificateDataCommonName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_metadata: Optional[str] = None,
                 static: Optional[str] = None):
        if device_metadata is not None:
            pulumi.set(__self__, "device_metadata", device_metadata)
        if static is not None:
            pulumi.set(__self__, "static", static)

    @property
    @pulumi.getter(name="deviceMetadata")
    def device_metadata(self) -> Optional[str]:
        return pulumi.get(self, "device_metadata")

    @property
    @pulumi.getter
    def static(self) -> Optional[str]:
        return pulumi.get(self, "static")


@pulumi.output_type
class DeviceCollectionAccountCertificateDataCountry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceMetadatas":
            suggest = "device_metadatas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceCollectionAccountCertificateDataCountry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceCollectionAccountCertificateDataCountry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceCollectionAccountCertificateDataCountry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")


@pulumi.output_type
class DeviceCollectionAccountCertificateDataLocality(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceMetadatas":
            suggest = "device_metadatas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceCollectionAccountCertificateDataLocality. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceCollectionAccountCertificateDataLocality.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceCollectionAccountCertificateDataLocality.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")


@pulumi.output_type
class DeviceCollectionAccountCertificateDataOrganization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceMetadatas":
            suggest = "device_metadatas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceCollectionAccountCertificateDataOrganization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceCollectionAccountCertificateDataOrganization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceCollectionAccountCertificateDataOrganization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")


@pulumi.output_type
class DeviceCollectionAccountCertificateDataOrganizationalUnit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceMetadatas":
            suggest = "device_metadatas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceCollectionAccountCertificateDataOrganizationalUnit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceCollectionAccountCertificateDataOrganizationalUnit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceCollectionAccountCertificateDataOrganizationalUnit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")


@pulumi.output_type
class DeviceCollectionAccountCertificateDataPostalCode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceMetadatas":
            suggest = "device_metadatas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceCollectionAccountCertificateDataPostalCode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceCollectionAccountCertificateDataPostalCode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceCollectionAccountCertificateDataPostalCode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")


@pulumi.output_type
class DeviceCollectionAccountCertificateDataProvince(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceMetadatas":
            suggest = "device_metadatas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceCollectionAccountCertificateDataProvince. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceCollectionAccountCertificateDataProvince.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceCollectionAccountCertificateDataProvince.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")


@pulumi.output_type
class DeviceCollectionAccountCertificateDataSans(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceMetadatas":
            suggest = "device_metadatas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceCollectionAccountCertificateDataSans. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceCollectionAccountCertificateDataSans.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceCollectionAccountCertificateDataSans.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")


@pulumi.output_type
class DeviceCollectionAccountCertificateDataStreetAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceMetadatas":
            suggest = "device_metadatas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceCollectionAccountCertificateDataStreetAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceCollectionAccountCertificateDataStreetAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceCollectionAccountCertificateDataStreetAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")


@pulumi.output_type
class DeviceCollectionAccountCertificateInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crtFile":
            suggest = "crt_file"
        elif key == "keyFile":
            suggest = "key_file"
        elif key == "rootFile":
            suggest = "root_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceCollectionAccountCertificateInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceCollectionAccountCertificateInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceCollectionAccountCertificateInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 crt_file: Optional[str] = None,
                 duration: Optional[str] = None,
                 gid: Optional[float] = None,
                 key_file: Optional[str] = None,
                 mode: Optional[float] = None,
                 root_file: Optional[str] = None,
                 uid: Optional[float] = None):
        """
        :param str type: The type of certificate. Allowed values: `X509` `SSH_USER` `SSH_HOST`
        :param str crt_file: The filepath where the certificate is to be stored.
        :param str duration: The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param float gid: GID of the files where the certificate is stored.
        :param str key_file: The filepath where the key is to be stored.
        :param float mode: Permission bits of the files where the certificate is stored.
        :param str root_file: The filepath where the root certificate is to be stored.
        :param float uid: UID of the files where the certificate is stored.
        """
        pulumi.set(__self__, "type", type)
        if crt_file is not None:
            pulumi.set(__self__, "crt_file", crt_file)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if gid is not None:
            pulumi.set(__self__, "gid", gid)
        if key_file is not None:
            pulumi.set(__self__, "key_file", key_file)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if root_file is not None:
            pulumi.set(__self__, "root_file", root_file)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of certificate. Allowed values: `X509` `SSH_USER` `SSH_HOST`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="crtFile")
    def crt_file(self) -> Optional[str]:
        """
        The filepath where the certificate is to be stored.
        """
        return pulumi.get(self, "crt_file")

    @property
    @pulumi.getter
    def duration(self) -> Optional[str]:
        """
        The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def gid(self) -> Optional[float]:
        """
        GID of the files where the certificate is stored.
        """
        return pulumi.get(self, "gid")

    @property
    @pulumi.getter(name="keyFile")
    def key_file(self) -> Optional[str]:
        """
        The filepath where the key is to be stored.
        """
        return pulumi.get(self, "key_file")

    @property
    @pulumi.getter
    def mode(self) -> Optional[float]:
        """
        Permission bits of the files where the certificate is stored.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="rootFile")
    def root_file(self) -> Optional[str]:
        """
        The filepath where the root certificate is to be stored.
        """
        return pulumi.get(self, "root_file")

    @property
    @pulumi.getter
    def uid(self) -> Optional[float]:
        """
        UID of the files where the certificate is stored.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class DeviceCollectionAccountKeyInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pubFile":
            suggest = "pub_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceCollectionAccountKeyInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceCollectionAccountKeyInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceCollectionAccountKeyInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format: str,
                 type: str,
                 protection: Optional[str] = None,
                 pub_file: Optional[str] = None):
        """
        :param str format: The format used to encode the private key. For X509 keys the default format is PKCS#8. The classic format is PKCS#1 for RSA keys, SEC 1 for ECDSA keys, and PKCS#8 for ED25519 keys. For SSH keys the default format is always the OPENSSH format. When a hardware module is used to store the keys the default will be a JSON representation of the key, except on Linux where tss2 will be used. Allowed values: `DEFAULT` `PKCS8` `OPENSSH` `TSS2` `CLASSIC`
        :param str type: The key type used. The current DEFAULT type is ECDSA_P256. Allowed values: `DEFAULT` `ECDSA_P256` `ECDSA_P384` `ECDSA_P521` `RSA_2048` `RSA_3072` `RSA_4096` `ED25519`
        :param str protection: Whether to use a hardware module to store the private key for a workload certificate. If set to `NONE` no hardware module will be used. If set to `DEFAULT` a hardware module will only be used with format `TSS2`. `HARDWARE_WITH_FALLBACK` can only be used with the key format `DEFAULT`. Allowed values: `DEFAULT` `NONE` `HARDWARE` `HARDWARE_WITH_FALLBACK` `HARDWARE_ATTESTED`
        :param str pub_file: A CSR or SSH public key to use instead of generating one.
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "type", type)
        if protection is not None:
            pulumi.set(__self__, "protection", protection)
        if pub_file is not None:
            pulumi.set(__self__, "pub_file", pub_file)

    @property
    @pulumi.getter
    def format(self) -> str:
        """
        The format used to encode the private key. For X509 keys the default format is PKCS#8. The classic format is PKCS#1 for RSA keys, SEC 1 for ECDSA keys, and PKCS#8 for ED25519 keys. For SSH keys the default format is always the OPENSSH format. When a hardware module is used to store the keys the default will be a JSON representation of the key, except on Linux where tss2 will be used. Allowed values: `DEFAULT` `PKCS8` `OPENSSH` `TSS2` `CLASSIC`
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The key type used. The current DEFAULT type is ECDSA_P256. Allowed values: `DEFAULT` `ECDSA_P256` `ECDSA_P384` `ECDSA_P521` `RSA_2048` `RSA_3072` `RSA_4096` `ED25519`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def protection(self) -> Optional[str]:
        """
        Whether to use a hardware module to store the private key for a workload certificate. If set to `NONE` no hardware module will be used. If set to `DEFAULT` a hardware module will only be used with format `TSS2`. `HARDWARE_WITH_FALLBACK` can only be used with the key format `DEFAULT`. Allowed values: `DEFAULT` `NONE` `HARDWARE` `HARDWARE_WITH_FALLBACK` `HARDWARE_ATTESTED`
        """
        return pulumi.get(self, "protection")

    @property
    @pulumi.getter(name="pubFile")
    def pub_file(self) -> Optional[str]:
        """
        A CSR or SSH public key to use instead of generating one.
        """
        return pulumi.get(self, "pub_file")


@pulumi.output_type
class DeviceCollectionAccountReloadInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pidFile":
            suggest = "pid_file"
        elif key == "unitName":
            suggest = "unit_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceCollectionAccountReloadInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceCollectionAccountReloadInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceCollectionAccountReloadInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: str,
                 pid_file: Optional[str] = None,
                 signal: Optional[float] = None,
                 unit_name: Optional[str] = None):
        """
        :param str method: Ways an endpoint can reload a certificate. `AUTOMATIC` means the process is able to detect and reload new certificates automatically. `CUSTOM` means a custom command must be run to trigger the workload to reload the certificates. `SIGNAL` will configure the agent to send a signal to the process in `pidFile`. `DBUS` will use the systemd system bus to issue a `try-reload-or-restart` job for unit specified by `unitName`. `PLATFORM` uses a method specific to the operating system. Allowed values: `AUTOMATIC` `CUSTOM` `SIGNAL` `DBUS` `PLATFORM`
        :param str pid_file: File that holds the pid of the process to signal. Required when method is SIGNAL.
        :param float signal: The signal to send to a process when a certificate should be reloaded. Required when method is SIGNAL.
        :param str unit_name: The systemd unit name to reload when a certificate should be reloaded. Required when method is DBUS.
        """
        pulumi.set(__self__, "method", method)
        if pid_file is not None:
            pulumi.set(__self__, "pid_file", pid_file)
        if signal is not None:
            pulumi.set(__self__, "signal", signal)
        if unit_name is not None:
            pulumi.set(__self__, "unit_name", unit_name)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        Ways an endpoint can reload a certificate. `AUTOMATIC` means the process is able to detect and reload new certificates automatically. `CUSTOM` means a custom command must be run to trigger the workload to reload the certificates. `SIGNAL` will configure the agent to send a signal to the process in `pidFile`. `DBUS` will use the systemd system bus to issue a `try-reload-or-restart` job for unit specified by `unitName`. `PLATFORM` uses a method specific to the operating system. Allowed values: `AUTOMATIC` `CUSTOM` `SIGNAL` `DBUS` `PLATFORM`
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="pidFile")
    def pid_file(self) -> Optional[str]:
        """
        File that holds the pid of the process to signal. Required when method is SIGNAL.
        """
        return pulumi.get(self, "pid_file")

    @property
    @pulumi.getter
    def signal(self) -> Optional[float]:
        """
        The signal to send to a process when a certificate should be reloaded. Required when method is SIGNAL.
        """
        return pulumi.get(self, "signal")

    @property
    @pulumi.getter(name="unitName")
    def unit_name(self) -> Optional[str]:
        """
        The systemd unit name to reload when a certificate should be reloaded. Required when method is DBUS.
        """
        return pulumi.get(self, "unit_name")


@pulumi.output_type
class DeviceCollectionAwsVm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableCustomSans":
            suggest = "disable_custom_sans"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceCollectionAwsVm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceCollectionAwsVm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceCollectionAwsVm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accounts: Sequence[str],
                 disable_custom_sans: Optional[bool] = None):
        """
        :param Sequence[str] accounts: The list of AWS account IDs that are allowed to use an AWS cloud provisioner.
        :param bool disable_custom_sans: By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid. These are the private IP and the DNS ip-<private-ip>.<region>.compute.internal.
        """
        pulumi.set(__self__, "accounts", accounts)
        if disable_custom_sans is not None:
            pulumi.set(__self__, "disable_custom_sans", disable_custom_sans)

    @property
    @pulumi.getter
    def accounts(self) -> Sequence[str]:
        """
        The list of AWS account IDs that are allowed to use an AWS cloud provisioner.
        """
        return pulumi.get(self, "accounts")

    @property
    @pulumi.getter(name="disableCustomSans")
    def disable_custom_sans(self) -> Optional[bool]:
        """
        By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid. These are the private IP and the DNS ip-<private-ip>.<region>.compute.internal.
        """
        return pulumi.get(self, "disable_custom_sans")


@pulumi.output_type
class DeviceCollectionAzureVm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroups":
            suggest = "resource_groups"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "disableCustomSans":
            suggest = "disable_custom_sans"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceCollectionAzureVm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceCollectionAzureVm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceCollectionAzureVm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_groups: Sequence[str],
                 tenant_id: str,
                 audience: Optional[str] = None,
                 disable_custom_sans: Optional[bool] = None):
        """
        :param Sequence[str] resource_groups: The list of resource group names that are allowed to use this provisioner.
        :param str tenant_id: The Azure account tenant ID for this provisioner. This ID is the Directory ID available in the Azure Active Directory properties.
        :param str audience: Defaults to https://management.azure.com/ but it can be changed if necessary.
        :param bool disable_custom_sans: By default custom SANs are valid, but if this option is set to `true` only the SANs available in the token will be valid, in Azure only the virtual machine name is available.
        """
        pulumi.set(__self__, "resource_groups", resource_groups)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if audience is not None:
            pulumi.set(__self__, "audience", audience)
        if disable_custom_sans is not None:
            pulumi.set(__self__, "disable_custom_sans", disable_custom_sans)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Sequence[str]:
        """
        The list of resource group names that are allowed to use this provisioner.
        """
        return pulumi.get(self, "resource_groups")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The Azure account tenant ID for this provisioner. This ID is the Directory ID available in the Azure Active Directory properties.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def audience(self) -> Optional[str]:
        """
        Defaults to https://management.azure.com/ but it can be changed if necessary.
        """
        return pulumi.get(self, "audience")

    @property
    @pulumi.getter(name="disableCustomSans")
    def disable_custom_sans(self) -> Optional[bool]:
        """
        By default custom SANs are valid, but if this option is set to `true` only the SANs available in the token will be valid, in Azure only the virtual machine name is available.
        """
        return pulumi.get(self, "disable_custom_sans")


@pulumi.output_type
class DeviceCollectionGcpVm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableCustomSans":
            suggest = "disable_custom_sans"
        elif key == "projectIds":
            suggest = "project_ids"
        elif key == "serviceAccounts":
            suggest = "service_accounts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceCollectionGcpVm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceCollectionGcpVm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceCollectionGcpVm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_custom_sans: Optional[bool] = None,
                 project_ids: Optional[Sequence[str]] = None,
                 service_accounts: Optional[Sequence[str]] = None):
        """
        :param bool disable_custom_sans: By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid, these are the DNS `<instance-name>.c.<project-id>.internal` and `<instance-name>.<zone>.c.<project-id>.internal`.
        :param Sequence[str] project_ids: The list of project identifiers that are allowed to use a GCP cloud provisioner.
        :param Sequence[str] service_accounts: The list of service accounts that are allowed to use a GCP cloud provisioner.
        """
        if disable_custom_sans is not None:
            pulumi.set(__self__, "disable_custom_sans", disable_custom_sans)
        if project_ids is not None:
            pulumi.set(__self__, "project_ids", project_ids)
        if service_accounts is not None:
            pulumi.set(__self__, "service_accounts", service_accounts)

    @property
    @pulumi.getter(name="disableCustomSans")
    def disable_custom_sans(self) -> Optional[bool]:
        """
        By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid, these are the DNS `<instance-name>.c.<project-id>.internal` and `<instance-name>.<zone>.c.<project-id>.internal`.
        """
        return pulumi.get(self, "disable_custom_sans")

    @property
    @pulumi.getter(name="projectIds")
    def project_ids(self) -> Optional[Sequence[str]]:
        """
        The list of project identifiers that are allowed to use a GCP cloud provisioner.
        """
        return pulumi.get(self, "project_ids")

    @property
    @pulumi.getter(name="serviceAccounts")
    def service_accounts(self) -> Optional[Sequence[str]]:
        """
        The list of service accounts that are allowed to use a GCP cloud provisioner.
        """
        return pulumi.get(self, "service_accounts")


@pulumi.output_type
class DeviceCollectionTpm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attestorIntermediates":
            suggest = "attestor_intermediates"
        elif key == "attestorRoots":
            suggest = "attestor_roots"
        elif key == "forceCn":
            suggest = "force_cn"
        elif key == "requireEab":
            suggest = "require_eab"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceCollectionTpm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceCollectionTpm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceCollectionTpm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attestor_intermediates: Optional[str] = None,
                 attestor_roots: Optional[str] = None,
                 force_cn: Optional[bool] = None,
                 require_eab: Optional[bool] = None):
        """
        :param str attestor_intermediates: The pem-encoded list of intermediate certificates used to build a chain of trust to verify the attestation certificates submitted by agents. Ignored if the team already has an attestation authority.
        :param str attestor_roots: The pem-encoded list of certificates used to verify the attestation certificates submitted by agents. Ignored if the team already has an attestation authority. Required if the team does not already have an attestation authority.
        :param bool force_cn: Force one of the SANs to become the Common Name, if a Common Name is not provided.
        :param bool require_eab: Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner.
        """
        if attestor_intermediates is not None:
            pulumi.set(__self__, "attestor_intermediates", attestor_intermediates)
        if attestor_roots is not None:
            pulumi.set(__self__, "attestor_roots", attestor_roots)
        if force_cn is not None:
            pulumi.set(__self__, "force_cn", force_cn)
        if require_eab is not None:
            pulumi.set(__self__, "require_eab", require_eab)

    @property
    @pulumi.getter(name="attestorIntermediates")
    def attestor_intermediates(self) -> Optional[str]:
        """
        The pem-encoded list of intermediate certificates used to build a chain of trust to verify the attestation certificates submitted by agents. Ignored if the team already has an attestation authority.
        """
        return pulumi.get(self, "attestor_intermediates")

    @property
    @pulumi.getter(name="attestorRoots")
    def attestor_roots(self) -> Optional[str]:
        """
        The pem-encoded list of certificates used to verify the attestation certificates submitted by agents. Ignored if the team already has an attestation authority. Required if the team does not already have an attestation authority.
        """
        return pulumi.get(self, "attestor_roots")

    @property
    @pulumi.getter(name="forceCn")
    def force_cn(self) -> Optional[bool]:
        """
        Force one of the SANs to become the Common Name, if a Common Name is not provided.
        """
        return pulumi.get(self, "force_cn")

    @property
    @pulumi.getter(name="requireEab")
    def require_eab(self) -> Optional[bool]:
        """
        Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner.
        """
        return pulumi.get(self, "require_eab")


@pulumi.output_type
class ProvisionerAcme(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requireEab":
            suggest = "require_eab"
        elif key == "forceCn":
            suggest = "force_cn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProvisionerAcme. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProvisionerAcme.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProvisionerAcme.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 challenges: Sequence[str],
                 require_eab: bool,
                 force_cn: Optional[bool] = None):
        """
        :param Sequence[str] challenges: Which ACME challenge types are allowed. Allowed values: `http-01` `dns-01` `tls-alpn-01`
        :param bool require_eab: Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner. Must be `true` for all new provisioners.
        :param bool force_cn: Force one of the SANs to become the Common Name, if a Common Name is not provided.
        """
        pulumi.set(__self__, "challenges", challenges)
        pulumi.set(__self__, "require_eab", require_eab)
        if force_cn is not None:
            pulumi.set(__self__, "force_cn", force_cn)

    @property
    @pulumi.getter
    def challenges(self) -> Sequence[str]:
        """
        Which ACME challenge types are allowed. Allowed values: `http-01` `dns-01` `tls-alpn-01`
        """
        return pulumi.get(self, "challenges")

    @property
    @pulumi.getter(name="requireEab")
    def require_eab(self) -> bool:
        """
        Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner. Must be `true` for all new provisioners.
        """
        return pulumi.get(self, "require_eab")

    @property
    @pulumi.getter(name="forceCn")
    def force_cn(self) -> Optional[bool]:
        """
        Force one of the SANs to become the Common Name, if a Common Name is not provided.
        """
        return pulumi.get(self, "force_cn")


@pulumi.output_type
class ProvisionerAcmeAttestation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attestationFormats":
            suggest = "attestation_formats"
        elif key == "attestationRoots":
            suggest = "attestation_roots"
        elif key == "forceCn":
            suggest = "force_cn"
        elif key == "requireEab":
            suggest = "require_eab"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProvisionerAcmeAttestation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProvisionerAcmeAttestation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProvisionerAcmeAttestation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attestation_formats: Sequence[str],
                 attestation_roots: Optional[Sequence[str]] = None,
                 force_cn: Optional[bool] = None,
                 require_eab: Optional[bool] = None):
        """
        :param Sequence[str] attestation_formats: The allowed attestation formats for the device-attest-01 challenge. Valid values are `apple`, `step`, and `tpm`. The apple format is for Apple devices, and adds trust for Apple's CAs. The step format is for non-TPM devices that can issue attestation certificates, such as YubiKey PIV. It adds trust for Yubico's root CA. The tpm format is for TPMs and does not trust any CAs by default. Allowed values: `apple` `step` `tpm`
        :param Sequence[str] attestation_roots: A trust bundle of root certificates in PEM format that will be used to verify attestation certificates. The default value depends on the value of attestationFormats. If provided, this PEM bundle will override the CA trust established by setting attestationFormats to apple or step. At least one root certificate is required when using the tpm attestationFormat.
        :param bool force_cn: Force one of the SANs to become the Common Name, if a Common Name is not provided.
        :param bool require_eab: Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner.
        """
        pulumi.set(__self__, "attestation_formats", attestation_formats)
        if attestation_roots is not None:
            pulumi.set(__self__, "attestation_roots", attestation_roots)
        if force_cn is not None:
            pulumi.set(__self__, "force_cn", force_cn)
        if require_eab is not None:
            pulumi.set(__self__, "require_eab", require_eab)

    @property
    @pulumi.getter(name="attestationFormats")
    def attestation_formats(self) -> Sequence[str]:
        """
        The allowed attestation formats for the device-attest-01 challenge. Valid values are `apple`, `step`, and `tpm`. The apple format is for Apple devices, and adds trust for Apple's CAs. The step format is for non-TPM devices that can issue attestation certificates, such as YubiKey PIV. It adds trust for Yubico's root CA. The tpm format is for TPMs and does not trust any CAs by default. Allowed values: `apple` `step` `tpm`
        """
        return pulumi.get(self, "attestation_formats")

    @property
    @pulumi.getter(name="attestationRoots")
    def attestation_roots(self) -> Optional[Sequence[str]]:
        """
        A trust bundle of root certificates in PEM format that will be used to verify attestation certificates. The default value depends on the value of attestationFormats. If provided, this PEM bundle will override the CA trust established by setting attestationFormats to apple or step. At least one root certificate is required when using the tpm attestationFormat.
        """
        return pulumi.get(self, "attestation_roots")

    @property
    @pulumi.getter(name="forceCn")
    def force_cn(self) -> Optional[bool]:
        """
        Force one of the SANs to become the Common Name, if a Common Name is not provided.
        """
        return pulumi.get(self, "force_cn")

    @property
    @pulumi.getter(name="requireEab")
    def require_eab(self) -> Optional[bool]:
        """
        Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner.
        """
        return pulumi.get(self, "require_eab")


@pulumi.output_type
class ProvisionerAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableCustomSans":
            suggest = "disable_custom_sans"
        elif key == "disableTrustOnFirstUse":
            suggest = "disable_trust_on_first_use"
        elif key == "instanceAge":
            suggest = "instance_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProvisionerAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProvisionerAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProvisionerAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accounts: Sequence[str],
                 disable_custom_sans: Optional[bool] = None,
                 disable_trust_on_first_use: Optional[bool] = None,
                 instance_age: Optional[str] = None):
        """
        :param Sequence[str] accounts: The list of AWS account IDs that are allowed to use an AWS cloud provisioner.
        :param bool disable_custom_sans: By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid. These are the private IP and the DNS ip-<private-ip>.<region>.compute.internal.
        :param bool disable_trust_on_first_use: By default only one certificate will be granted per instance, but if the option is set to `true` this limit is not set and different tokens can be used to get different certificates.
        :param str instance_age: The maximum age of an instance that should be allowed to obtain a certificate. Limits certificate issuance to new instances to mitigate the risk of credential-misuse from instances that don't need a certificate. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        pulumi.set(__self__, "accounts", accounts)
        if disable_custom_sans is not None:
            pulumi.set(__self__, "disable_custom_sans", disable_custom_sans)
        if disable_trust_on_first_use is not None:
            pulumi.set(__self__, "disable_trust_on_first_use", disable_trust_on_first_use)
        if instance_age is not None:
            pulumi.set(__self__, "instance_age", instance_age)

    @property
    @pulumi.getter
    def accounts(self) -> Sequence[str]:
        """
        The list of AWS account IDs that are allowed to use an AWS cloud provisioner.
        """
        return pulumi.get(self, "accounts")

    @property
    @pulumi.getter(name="disableCustomSans")
    def disable_custom_sans(self) -> Optional[bool]:
        """
        By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid. These are the private IP and the DNS ip-<private-ip>.<region>.compute.internal.
        """
        return pulumi.get(self, "disable_custom_sans")

    @property
    @pulumi.getter(name="disableTrustOnFirstUse")
    def disable_trust_on_first_use(self) -> Optional[bool]:
        """
        By default only one certificate will be granted per instance, but if the option is set to `true` this limit is not set and different tokens can be used to get different certificates.
        """
        return pulumi.get(self, "disable_trust_on_first_use")

    @property
    @pulumi.getter(name="instanceAge")
    def instance_age(self) -> Optional[str]:
        """
        The maximum age of an instance that should be allowed to obtain a certificate. Limits certificate issuance to new instances to mitigate the risk of credential-misuse from instances that don't need a certificate. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "instance_age")


@pulumi.output_type
class ProvisionerAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroups":
            suggest = "resource_groups"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "disableCustomSans":
            suggest = "disable_custom_sans"
        elif key == "disableTrustOnFirstUse":
            suggest = "disable_trust_on_first_use"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProvisionerAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProvisionerAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProvisionerAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_groups: Sequence[str],
                 tenant_id: str,
                 audience: Optional[str] = None,
                 disable_custom_sans: Optional[bool] = None,
                 disable_trust_on_first_use: Optional[bool] = None):
        """
        :param Sequence[str] resource_groups: The list of resource group names that are allowed to use this provisioner.
        :param str tenant_id: The Azure account tenant ID for this provisioner. This ID is the Directory ID available in the Azure Active Directory properties.
        :param str audience: Defaults to https://management.azure.com/ but it can be changed if necessary.
        :param bool disable_custom_sans: By default custom SANs are valid, but if this option is set to `true` only the SANs available in the token will be valid, in Azure only the virtual machine name is available.
        :param bool disable_trust_on_first_use: By default only one certificate will be granted per instance, but if the option is set to true this limit is not set and different tokens can be used to get different certificates.
        """
        pulumi.set(__self__, "resource_groups", resource_groups)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if audience is not None:
            pulumi.set(__self__, "audience", audience)
        if disable_custom_sans is not None:
            pulumi.set(__self__, "disable_custom_sans", disable_custom_sans)
        if disable_trust_on_first_use is not None:
            pulumi.set(__self__, "disable_trust_on_first_use", disable_trust_on_first_use)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Sequence[str]:
        """
        The list of resource group names that are allowed to use this provisioner.
        """
        return pulumi.get(self, "resource_groups")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The Azure account tenant ID for this provisioner. This ID is the Directory ID available in the Azure Active Directory properties.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def audience(self) -> Optional[str]:
        """
        Defaults to https://management.azure.com/ but it can be changed if necessary.
        """
        return pulumi.get(self, "audience")

    @property
    @pulumi.getter(name="disableCustomSans")
    def disable_custom_sans(self) -> Optional[bool]:
        """
        By default custom SANs are valid, but if this option is set to `true` only the SANs available in the token will be valid, in Azure only the virtual machine name is available.
        """
        return pulumi.get(self, "disable_custom_sans")

    @property
    @pulumi.getter(name="disableTrustOnFirstUse")
    def disable_trust_on_first_use(self) -> Optional[bool]:
        """
        By default only one certificate will be granted per instance, but if the option is set to true this limit is not set and different tokens can be used to get different certificates.
        """
        return pulumi.get(self, "disable_trust_on_first_use")


@pulumi.output_type
class ProvisionerClaims(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRenewalAfterExpiry":
            suggest = "allow_renewal_after_expiry"
        elif key == "defaultHostSshCertDuration":
            suggest = "default_host_ssh_cert_duration"
        elif key == "defaultTlsCertDuration":
            suggest = "default_tls_cert_duration"
        elif key == "defaultUserSshCertDuration":
            suggest = "default_user_ssh_cert_duration"
        elif key == "disableRenewal":
            suggest = "disable_renewal"
        elif key == "enableSshCa":
            suggest = "enable_ssh_ca"
        elif key == "maxHostSshCertDuration":
            suggest = "max_host_ssh_cert_duration"
        elif key == "maxTlsCertDuration":
            suggest = "max_tls_cert_duration"
        elif key == "maxUserSshCertDuration":
            suggest = "max_user_ssh_cert_duration"
        elif key == "minHostSshCertDuration":
            suggest = "min_host_ssh_cert_duration"
        elif key == "minTlsCertDuration":
            suggest = "min_tls_cert_duration"
        elif key == "minUserSshCertDuration":
            suggest = "min_user_ssh_cert_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProvisionerClaims. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProvisionerClaims.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProvisionerClaims.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_renewal_after_expiry: Optional[bool] = None,
                 default_host_ssh_cert_duration: Optional[str] = None,
                 default_tls_cert_duration: Optional[str] = None,
                 default_user_ssh_cert_duration: Optional[str] = None,
                 disable_renewal: Optional[bool] = None,
                 enable_ssh_ca: Optional[bool] = None,
                 max_host_ssh_cert_duration: Optional[str] = None,
                 max_tls_cert_duration: Optional[str] = None,
                 max_user_ssh_cert_duration: Optional[str] = None,
                 min_host_ssh_cert_duration: Optional[str] = None,
                 min_tls_cert_duration: Optional[str] = None,
                 min_user_ssh_cert_duration: Optional[str] = None):
        """
        :param bool allow_renewal_after_expiry: Allow renewals for expired certificates generated by this provisioner.
        :param str default_host_ssh_cert_duration: The default duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param str default_tls_cert_duration: The default duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param str default_user_ssh_cert_duration: The default duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param bool disable_renewal: Disable renewal for all certificates generated by this provisioner.
        :param bool enable_ssh_ca: Allow this provisioner to be used to generate SSH certificates.
        :param str max_host_ssh_cert_duration: The maximum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param str max_tls_cert_duration: The maximum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param str max_user_ssh_cert_duration: The maximum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param str min_host_ssh_cert_duration: The minimum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param str min_tls_cert_duration: The minimum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param str min_user_ssh_cert_duration: The minimum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        if allow_renewal_after_expiry is not None:
            pulumi.set(__self__, "allow_renewal_after_expiry", allow_renewal_after_expiry)
        if default_host_ssh_cert_duration is not None:
            pulumi.set(__self__, "default_host_ssh_cert_duration", default_host_ssh_cert_duration)
        if default_tls_cert_duration is not None:
            pulumi.set(__self__, "default_tls_cert_duration", default_tls_cert_duration)
        if default_user_ssh_cert_duration is not None:
            pulumi.set(__self__, "default_user_ssh_cert_duration", default_user_ssh_cert_duration)
        if disable_renewal is not None:
            pulumi.set(__self__, "disable_renewal", disable_renewal)
        if enable_ssh_ca is not None:
            pulumi.set(__self__, "enable_ssh_ca", enable_ssh_ca)
        if max_host_ssh_cert_duration is not None:
            pulumi.set(__self__, "max_host_ssh_cert_duration", max_host_ssh_cert_duration)
        if max_tls_cert_duration is not None:
            pulumi.set(__self__, "max_tls_cert_duration", max_tls_cert_duration)
        if max_user_ssh_cert_duration is not None:
            pulumi.set(__self__, "max_user_ssh_cert_duration", max_user_ssh_cert_duration)
        if min_host_ssh_cert_duration is not None:
            pulumi.set(__self__, "min_host_ssh_cert_duration", min_host_ssh_cert_duration)
        if min_tls_cert_duration is not None:
            pulumi.set(__self__, "min_tls_cert_duration", min_tls_cert_duration)
        if min_user_ssh_cert_duration is not None:
            pulumi.set(__self__, "min_user_ssh_cert_duration", min_user_ssh_cert_duration)

    @property
    @pulumi.getter(name="allowRenewalAfterExpiry")
    def allow_renewal_after_expiry(self) -> Optional[bool]:
        """
        Allow renewals for expired certificates generated by this provisioner.
        """
        return pulumi.get(self, "allow_renewal_after_expiry")

    @property
    @pulumi.getter(name="defaultHostSshCertDuration")
    def default_host_ssh_cert_duration(self) -> Optional[str]:
        """
        The default duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "default_host_ssh_cert_duration")

    @property
    @pulumi.getter(name="defaultTlsCertDuration")
    def default_tls_cert_duration(self) -> Optional[str]:
        """
        The default duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "default_tls_cert_duration")

    @property
    @pulumi.getter(name="defaultUserSshCertDuration")
    def default_user_ssh_cert_duration(self) -> Optional[str]:
        """
        The default duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "default_user_ssh_cert_duration")

    @property
    @pulumi.getter(name="disableRenewal")
    def disable_renewal(self) -> Optional[bool]:
        """
        Disable renewal for all certificates generated by this provisioner.
        """
        return pulumi.get(self, "disable_renewal")

    @property
    @pulumi.getter(name="enableSshCa")
    def enable_ssh_ca(self) -> Optional[bool]:
        """
        Allow this provisioner to be used to generate SSH certificates.
        """
        return pulumi.get(self, "enable_ssh_ca")

    @property
    @pulumi.getter(name="maxHostSshCertDuration")
    def max_host_ssh_cert_duration(self) -> Optional[str]:
        """
        The maximum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "max_host_ssh_cert_duration")

    @property
    @pulumi.getter(name="maxTlsCertDuration")
    def max_tls_cert_duration(self) -> Optional[str]:
        """
        The maximum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "max_tls_cert_duration")

    @property
    @pulumi.getter(name="maxUserSshCertDuration")
    def max_user_ssh_cert_duration(self) -> Optional[str]:
        """
        The maximum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "max_user_ssh_cert_duration")

    @property
    @pulumi.getter(name="minHostSshCertDuration")
    def min_host_ssh_cert_duration(self) -> Optional[str]:
        """
        The minimum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "min_host_ssh_cert_duration")

    @property
    @pulumi.getter(name="minTlsCertDuration")
    def min_tls_cert_duration(self) -> Optional[str]:
        """
        The minimum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "min_tls_cert_duration")

    @property
    @pulumi.getter(name="minUserSshCertDuration")
    def min_user_ssh_cert_duration(self) -> Optional[str]:
        """
        The minimum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "min_user_ssh_cert_duration")


@pulumi.output_type
class ProvisionerGcp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectIds":
            suggest = "project_ids"
        elif key == "serviceAccounts":
            suggest = "service_accounts"
        elif key == "disableCustomSans":
            suggest = "disable_custom_sans"
        elif key == "disableTrustOnFirstUse":
            suggest = "disable_trust_on_first_use"
        elif key == "instanceAge":
            suggest = "instance_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProvisionerGcp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProvisionerGcp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProvisionerGcp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_ids: Sequence[str],
                 service_accounts: Sequence[str],
                 disable_custom_sans: Optional[bool] = None,
                 disable_trust_on_first_use: Optional[bool] = None,
                 instance_age: Optional[str] = None):
        """
        :param Sequence[str] project_ids: The list of project identifiers that are allowed to use a GCP cloud provisioner.
        :param Sequence[str] service_accounts: The list of service accounts that are allowed to use a GCP cloud provisioner.
        :param bool disable_custom_sans: By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid, these are the DNS `<instance-name>.c.<project-id>.internal` and `<instance-name>.<zone>.c.<project-id>.internal`.
        :param bool disable_trust_on_first_use: By default only one certificate will be granted per instance, but if the option is set to `true` this limit is not set and different tokens can be used to get different certificates.
        :param str instance_age: The maximum age of an instance that should be allowed to obtain a certificate. Limits certificate issuance to new instances to mitigate the risk of credential-misuse from instances that don't need a certificate. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        pulumi.set(__self__, "project_ids", project_ids)
        pulumi.set(__self__, "service_accounts", service_accounts)
        if disable_custom_sans is not None:
            pulumi.set(__self__, "disable_custom_sans", disable_custom_sans)
        if disable_trust_on_first_use is not None:
            pulumi.set(__self__, "disable_trust_on_first_use", disable_trust_on_first_use)
        if instance_age is not None:
            pulumi.set(__self__, "instance_age", instance_age)

    @property
    @pulumi.getter(name="projectIds")
    def project_ids(self) -> Sequence[str]:
        """
        The list of project identifiers that are allowed to use a GCP cloud provisioner.
        """
        return pulumi.get(self, "project_ids")

    @property
    @pulumi.getter(name="serviceAccounts")
    def service_accounts(self) -> Sequence[str]:
        """
        The list of service accounts that are allowed to use a GCP cloud provisioner.
        """
        return pulumi.get(self, "service_accounts")

    @property
    @pulumi.getter(name="disableCustomSans")
    def disable_custom_sans(self) -> Optional[bool]:
        """
        By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid, these are the DNS `<instance-name>.c.<project-id>.internal` and `<instance-name>.<zone>.c.<project-id>.internal`.
        """
        return pulumi.get(self, "disable_custom_sans")

    @property
    @pulumi.getter(name="disableTrustOnFirstUse")
    def disable_trust_on_first_use(self) -> Optional[bool]:
        """
        By default only one certificate will be granted per instance, but if the option is set to `true` this limit is not set and different tokens can be used to get different certificates.
        """
        return pulumi.get(self, "disable_trust_on_first_use")

    @property
    @pulumi.getter(name="instanceAge")
    def instance_age(self) -> Optional[str]:
        """
        The maximum age of an instance that should be allowed to obtain a certificate. Limits certificate issuance to new instances to mitigate the risk of credential-misuse from instances that don't need a certificate. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "instance_age")


@pulumi.output_type
class ProvisionerJwk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptedKey":
            suggest = "encrypted_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProvisionerJwk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProvisionerJwk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProvisionerJwk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 encrypted_key: Optional[str] = None):
        """
        :param str key: The public JSON web key.
        :param str encrypted_key: The JWE encrypted private key.
        """
        pulumi.set(__self__, "key", key)
        if encrypted_key is not None:
            pulumi.set(__self__, "encrypted_key", encrypted_key)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The public JSON web key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="encryptedKey")
    def encrypted_key(self) -> Optional[str]:
        """
        The JWE encrypted private key.
        """
        return pulumi.get(self, "encrypted_key")


@pulumi.output_type
class ProvisionerOidc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "configurationEndpoint":
            suggest = "configuration_endpoint"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "listenAddress":
            suggest = "listen_address"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProvisionerOidc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProvisionerOidc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProvisionerOidc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 configuration_endpoint: str,
                 admins: Optional[Sequence[str]] = None,
                 client_secret: Optional[str] = None,
                 domains: Optional[Sequence[str]] = None,
                 groups: Optional[Sequence[str]] = None,
                 listen_address: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str client_id: The id used to validate the audience in an OpenID Connect token.
        :param str configuration_endpoint: OpenID Connect configuration URL.
        :param Sequence[str] admins: The emails of admin users in an OpenID Connect provisioner. These users will not have restrictions in the certificates to sign.
        :param str client_secret: The secret used to obtain the OpenID Connect tokens.
        :param Sequence[str] domains: The domains used to validate the email claim in an OpenID Connect provisioner.
        :param Sequence[str] groups: The group list used to validate the groups extension in an OpenID Connect token.
        :param str listen_address: The callback address used in the OpenID Connect flow.
        :param str tenant_id: The tenant-id used to replace the templatized tenantid value in the OpenID Configuration.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "configuration_endpoint", configuration_endpoint)
        if admins is not None:
            pulumi.set(__self__, "admins", admins)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if domains is not None:
            pulumi.set(__self__, "domains", domains)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if listen_address is not None:
            pulumi.set(__self__, "listen_address", listen_address)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The id used to validate the audience in an OpenID Connect token.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="configurationEndpoint")
    def configuration_endpoint(self) -> str:
        """
        OpenID Connect configuration URL.
        """
        return pulumi.get(self, "configuration_endpoint")

    @property
    @pulumi.getter
    def admins(self) -> Optional[Sequence[str]]:
        """
        The emails of admin users in an OpenID Connect provisioner. These users will not have restrictions in the certificates to sign.
        """
        return pulumi.get(self, "admins")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The secret used to obtain the OpenID Connect tokens.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def domains(self) -> Optional[Sequence[str]]:
        """
        The domains used to validate the email claim in an OpenID Connect provisioner.
        """
        return pulumi.get(self, "domains")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        """
        The group list used to validate the groups extension in an OpenID Connect token.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter(name="listenAddress")
    def listen_address(self) -> Optional[str]:
        """
        The callback address used in the OpenID Connect flow.
        """
        return pulumi.get(self, "listen_address")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The tenant-id used to replace the templatized tenantid value in the OpenID Configuration.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class ProvisionerOptions(dict):
    def __init__(__self__, *,
                 ssh: Optional['outputs.ProvisionerOptionsSsh'] = None,
                 x509: Optional['outputs.ProvisionerOptionsX509'] = None):
        """
        :param 'ProvisionerOptionsSshArgs' ssh: Options that apply when issuing SSH certificates
        :param 'ProvisionerOptionsX509Args' x509: Options that apply when issuing x509 certificates.
        """
        if ssh is not None:
            pulumi.set(__self__, "ssh", ssh)
        if x509 is not None:
            pulumi.set(__self__, "x509", x509)

    @property
    @pulumi.getter
    def ssh(self) -> Optional['outputs.ProvisionerOptionsSsh']:
        """
        Options that apply when issuing SSH certificates
        """
        return pulumi.get(self, "ssh")

    @property
    @pulumi.getter
    def x509(self) -> Optional['outputs.ProvisionerOptionsX509']:
        """
        Options that apply when issuing x509 certificates.
        """
        return pulumi.get(self, "x509")


@pulumi.output_type
class ProvisionerOptionsSsh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "templateData":
            suggest = "template_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProvisionerOptionsSsh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProvisionerOptionsSsh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProvisionerOptionsSsh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template: Optional[str] = None,
                 template_data: Optional[str] = None):
        """
        :param str template: A JSON representation of the SSH certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#ssh-templates).
        :param str template_data: A map of data that can be used by the certificate template.
        """
        if template is not None:
            pulumi.set(__self__, "template", template)
        if template_data is not None:
            pulumi.set(__self__, "template_data", template_data)

    @property
    @pulumi.getter
    def template(self) -> Optional[str]:
        """
        A JSON representation of the SSH certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#ssh-templates).
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter(name="templateData")
    def template_data(self) -> Optional[str]:
        """
        A map of data that can be used by the certificate template.
        """
        return pulumi.get(self, "template_data")


@pulumi.output_type
class ProvisionerOptionsX509(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "templateData":
            suggest = "template_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProvisionerOptionsX509. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProvisionerOptionsX509.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProvisionerOptionsX509.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template: Optional[str] = None,
                 template_data: Optional[str] = None):
        """
        :param str template: A JSON representation of the x509 certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#x509-templates).
        :param str template_data: A map of data that can be used by the certificate template.
        """
        if template is not None:
            pulumi.set(__self__, "template", template)
        if template_data is not None:
            pulumi.set(__self__, "template_data", template_data)

    @property
    @pulumi.getter
    def template(self) -> Optional[str]:
        """
        A JSON representation of the x509 certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#x509-templates).
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter(name="templateData")
    def template_data(self) -> Optional[str]:
        """
        A map of data that can be used by the certificate template.
        """
        return pulumi.get(self, "template_data")


@pulumi.output_type
class ProvisionerWebhookBasicAuth(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")


@pulumi.output_type
class ProvisionerX5c(dict):
    def __init__(__self__, *,
                 roots: Sequence[str]):
        """
        :param Sequence[str] roots: A list of pem-encoded x509 certificates. Any certificate bundle that chains up to any of these roots can be used in a certificate request.
        """
        pulumi.set(__self__, "roots", roots)

    @property
    @pulumi.getter
    def roots(self) -> Sequence[str]:
        """
        A list of pem-encoded x509 certificates. Any certificate bundle that chains up to any of these roots can be used in a certificate request.
        """
        return pulumi.get(self, "roots")


@pulumi.output_type
class WorkloadCertificateData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commonName":
            suggest = "common_name"
        elif key == "organizationalUnit":
            suggest = "organizational_unit"
        elif key == "postalCode":
            suggest = "postal_code"
        elif key == "streetAddress":
            suggest = "street_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadCertificateData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadCertificateData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadCertificateData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 common_name: 'outputs.WorkloadCertificateDataCommonName',
                 country: Optional['outputs.WorkloadCertificateDataCountry'] = None,
                 locality: Optional['outputs.WorkloadCertificateDataLocality'] = None,
                 organization: Optional['outputs.WorkloadCertificateDataOrganization'] = None,
                 organizational_unit: Optional['outputs.WorkloadCertificateDataOrganizationalUnit'] = None,
                 postal_code: Optional['outputs.WorkloadCertificateDataPostalCode'] = None,
                 province: Optional['outputs.WorkloadCertificateDataProvince'] = None,
                 sans: Optional['outputs.WorkloadCertificateDataSans'] = None,
                 street_address: Optional['outputs.WorkloadCertificateDataStreetAddress'] = None):
        pulumi.set(__self__, "common_name", common_name)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if locality is not None:
            pulumi.set(__self__, "locality", locality)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if organizational_unit is not None:
            pulumi.set(__self__, "organizational_unit", organizational_unit)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if province is not None:
            pulumi.set(__self__, "province", province)
        if sans is not None:
            pulumi.set(__self__, "sans", sans)
        if street_address is not None:
            pulumi.set(__self__, "street_address", street_address)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> 'outputs.WorkloadCertificateDataCommonName':
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter
    def country(self) -> Optional['outputs.WorkloadCertificateDataCountry']:
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def locality(self) -> Optional['outputs.WorkloadCertificateDataLocality']:
        return pulumi.get(self, "locality")

    @property
    @pulumi.getter
    def organization(self) -> Optional['outputs.WorkloadCertificateDataOrganization']:
        return pulumi.get(self, "organization")

    @property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> Optional['outputs.WorkloadCertificateDataOrganizationalUnit']:
        return pulumi.get(self, "organizational_unit")

    @property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional['outputs.WorkloadCertificateDataPostalCode']:
        return pulumi.get(self, "postal_code")

    @property
    @pulumi.getter
    def province(self) -> Optional['outputs.WorkloadCertificateDataProvince']:
        return pulumi.get(self, "province")

    @property
    @pulumi.getter
    def sans(self) -> Optional['outputs.WorkloadCertificateDataSans']:
        return pulumi.get(self, "sans")

    @property
    @pulumi.getter(name="streetAddress")
    def street_address(self) -> Optional['outputs.WorkloadCertificateDataStreetAddress']:
        return pulumi.get(self, "street_address")


@pulumi.output_type
class WorkloadCertificateDataCommonName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceMetadata":
            suggest = "device_metadata"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadCertificateDataCommonName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadCertificateDataCommonName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadCertificateDataCommonName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_metadata: Optional[str] = None,
                 static: Optional[str] = None):
        if device_metadata is not None:
            pulumi.set(__self__, "device_metadata", device_metadata)
        if static is not None:
            pulumi.set(__self__, "static", static)

    @property
    @pulumi.getter(name="deviceMetadata")
    def device_metadata(self) -> Optional[str]:
        return pulumi.get(self, "device_metadata")

    @property
    @pulumi.getter
    def static(self) -> Optional[str]:
        return pulumi.get(self, "static")


@pulumi.output_type
class WorkloadCertificateDataCountry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceMetadatas":
            suggest = "device_metadatas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadCertificateDataCountry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadCertificateDataCountry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadCertificateDataCountry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")


@pulumi.output_type
class WorkloadCertificateDataLocality(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceMetadatas":
            suggest = "device_metadatas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadCertificateDataLocality. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadCertificateDataLocality.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadCertificateDataLocality.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")


@pulumi.output_type
class WorkloadCertificateDataOrganization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceMetadatas":
            suggest = "device_metadatas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadCertificateDataOrganization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadCertificateDataOrganization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadCertificateDataOrganization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")


@pulumi.output_type
class WorkloadCertificateDataOrganizationalUnit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceMetadatas":
            suggest = "device_metadatas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadCertificateDataOrganizationalUnit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadCertificateDataOrganizationalUnit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadCertificateDataOrganizationalUnit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")


@pulumi.output_type
class WorkloadCertificateDataPostalCode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceMetadatas":
            suggest = "device_metadatas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadCertificateDataPostalCode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadCertificateDataPostalCode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadCertificateDataPostalCode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")


@pulumi.output_type
class WorkloadCertificateDataProvince(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceMetadatas":
            suggest = "device_metadatas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadCertificateDataProvince. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadCertificateDataProvince.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadCertificateDataProvince.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")


@pulumi.output_type
class WorkloadCertificateDataSans(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceMetadatas":
            suggest = "device_metadatas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadCertificateDataSans. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadCertificateDataSans.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadCertificateDataSans.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")


@pulumi.output_type
class WorkloadCertificateDataStreetAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceMetadatas":
            suggest = "device_metadatas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadCertificateDataStreetAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadCertificateDataStreetAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadCertificateDataStreetAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")


@pulumi.output_type
class WorkloadCertificateInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crtFile":
            suggest = "crt_file"
        elif key == "keyFile":
            suggest = "key_file"
        elif key == "rootFile":
            suggest = "root_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadCertificateInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadCertificateInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadCertificateInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 crt_file: Optional[str] = None,
                 duration: Optional[str] = None,
                 gid: Optional[float] = None,
                 key_file: Optional[str] = None,
                 mode: Optional[float] = None,
                 root_file: Optional[str] = None,
                 uid: Optional[float] = None):
        """
        :param str type: The type of certificate. Allowed values: `X509` `SSH_USER` `SSH_HOST`
        :param str crt_file: The filepath where the certificate is to be stored.
        :param str duration: The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param float gid: GID of the files where the certificate is stored.
        :param str key_file: The filepath where the key is to be stored.
        :param float mode: Permission bits of the files where the certificate is stored.
        :param str root_file: The filepath where the root certificate is to be stored.
        :param float uid: UID of the files where the certificate is stored.
        """
        pulumi.set(__self__, "type", type)
        if crt_file is not None:
            pulumi.set(__self__, "crt_file", crt_file)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if gid is not None:
            pulumi.set(__self__, "gid", gid)
        if key_file is not None:
            pulumi.set(__self__, "key_file", key_file)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if root_file is not None:
            pulumi.set(__self__, "root_file", root_file)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of certificate. Allowed values: `X509` `SSH_USER` `SSH_HOST`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="crtFile")
    def crt_file(self) -> Optional[str]:
        """
        The filepath where the certificate is to be stored.
        """
        return pulumi.get(self, "crt_file")

    @property
    @pulumi.getter
    def duration(self) -> Optional[str]:
        """
        The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def gid(self) -> Optional[float]:
        """
        GID of the files where the certificate is stored.
        """
        return pulumi.get(self, "gid")

    @property
    @pulumi.getter(name="keyFile")
    def key_file(self) -> Optional[str]:
        """
        The filepath where the key is to be stored.
        """
        return pulumi.get(self, "key_file")

    @property
    @pulumi.getter
    def mode(self) -> Optional[float]:
        """
        Permission bits of the files where the certificate is stored.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="rootFile")
    def root_file(self) -> Optional[str]:
        """
        The filepath where the root certificate is to be stored.
        """
        return pulumi.get(self, "root_file")

    @property
    @pulumi.getter
    def uid(self) -> Optional[float]:
        """
        UID of the files where the certificate is stored.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class WorkloadHooks(dict):
    def __init__(__self__, *,
                 renew: Optional['outputs.WorkloadHooksRenew'] = None,
                 sign: Optional['outputs.WorkloadHooksSign'] = None):
        """
        :param 'WorkloadHooksRenewArgs' renew: A list of commands to run before and after a certificate is granted.
        :param 'WorkloadHooksSignArgs' sign: A list of commands to run before and after a certificate is granted.
        """
        if renew is not None:
            pulumi.set(__self__, "renew", renew)
        if sign is not None:
            pulumi.set(__self__, "sign", sign)

    @property
    @pulumi.getter
    def renew(self) -> Optional['outputs.WorkloadHooksRenew']:
        """
        A list of commands to run before and after a certificate is granted.
        """
        return pulumi.get(self, "renew")

    @property
    @pulumi.getter
    def sign(self) -> Optional['outputs.WorkloadHooksSign']:
        """
        A list of commands to run before and after a certificate is granted.
        """
        return pulumi.get(self, "sign")


@pulumi.output_type
class WorkloadHooksRenew(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onErrors":
            suggest = "on_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadHooksRenew. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadHooksRenew.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadHooksRenew.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 afters: Optional[Sequence[str]] = None,
                 befores: Optional[Sequence[str]] = None,
                 on_errors: Optional[Sequence[str]] = None,
                 shell: Optional[str] = None):
        """
        :param Sequence[str] afters: List of commands to run after the operation.
        :param Sequence[str] befores: List of commands to run before the operation.
        :param Sequence[str] on_errors: List of commands to run when the operation fails.
        :param str shell: The shell to use to execute the commands.
        """
        if afters is not None:
            pulumi.set(__self__, "afters", afters)
        if befores is not None:
            pulumi.set(__self__, "befores", befores)
        if on_errors is not None:
            pulumi.set(__self__, "on_errors", on_errors)
        if shell is not None:
            pulumi.set(__self__, "shell", shell)

    @property
    @pulumi.getter
    def afters(self) -> Optional[Sequence[str]]:
        """
        List of commands to run after the operation.
        """
        return pulumi.get(self, "afters")

    @property
    @pulumi.getter
    def befores(self) -> Optional[Sequence[str]]:
        """
        List of commands to run before the operation.
        """
        return pulumi.get(self, "befores")

    @property
    @pulumi.getter(name="onErrors")
    def on_errors(self) -> Optional[Sequence[str]]:
        """
        List of commands to run when the operation fails.
        """
        return pulumi.get(self, "on_errors")

    @property
    @pulumi.getter
    def shell(self) -> Optional[str]:
        """
        The shell to use to execute the commands.
        """
        return pulumi.get(self, "shell")


@pulumi.output_type
class WorkloadHooksSign(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onErrors":
            suggest = "on_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadHooksSign. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadHooksSign.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadHooksSign.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 afters: Optional[Sequence[str]] = None,
                 befores: Optional[Sequence[str]] = None,
                 on_errors: Optional[Sequence[str]] = None,
                 shell: Optional[str] = None):
        """
        :param Sequence[str] afters: List of commands to run after the operation.
        :param Sequence[str] befores: List of commands to run before the operation.
        :param Sequence[str] on_errors: List of commands to run when the operation fails.
        :param str shell: The shell to use to execute the commands.
        """
        if afters is not None:
            pulumi.set(__self__, "afters", afters)
        if befores is not None:
            pulumi.set(__self__, "befores", befores)
        if on_errors is not None:
            pulumi.set(__self__, "on_errors", on_errors)
        if shell is not None:
            pulumi.set(__self__, "shell", shell)

    @property
    @pulumi.getter
    def afters(self) -> Optional[Sequence[str]]:
        """
        List of commands to run after the operation.
        """
        return pulumi.get(self, "afters")

    @property
    @pulumi.getter
    def befores(self) -> Optional[Sequence[str]]:
        """
        List of commands to run before the operation.
        """
        return pulumi.get(self, "befores")

    @property
    @pulumi.getter(name="onErrors")
    def on_errors(self) -> Optional[Sequence[str]]:
        """
        List of commands to run when the operation fails.
        """
        return pulumi.get(self, "on_errors")

    @property
    @pulumi.getter
    def shell(self) -> Optional[str]:
        """
        The shell to use to execute the commands.
        """
        return pulumi.get(self, "shell")


@pulumi.output_type
class WorkloadKeyInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pubFile":
            suggest = "pub_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadKeyInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadKeyInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadKeyInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format: str,
                 type: str,
                 protection: Optional[str] = None,
                 pub_file: Optional[str] = None):
        """
        :param str format: The format used to encode the private key. For X509 keys the default format is PKCS#8. The classic format is PKCS#1 for RSA keys, SEC 1 for ECDSA keys, and PKCS#8 for ED25519 keys. For SSH keys the default format is always the OPENSSH format. When a hardware module is used to store the keys the default will be a JSON representation of the key, except on Linux where tss2 will be used. Allowed values: `DEFAULT` `PKCS8` `OPENSSH` `TSS2` `CLASSIC`
        :param str type: The key type used. The current DEFAULT type is ECDSA_P256. Allowed values: `DEFAULT` `ECDSA_P256` `ECDSA_P384` `ECDSA_P521` `RSA_2048` `RSA_3072` `RSA_4096` `ED25519`
        :param str protection: Whether to use a hardware module to store the private key for a workload certificate. If set to `NONE` no hardware module will be used. If set to `DEFAULT` a hardware module will only be used with format `TSS2`. `HARDWARE_WITH_FALLBACK` can only be used with the key format `DEFAULT`. Allowed values: `DEFAULT` `NONE` `HARDWARE` `HARDWARE_WITH_FALLBACK` `HARDWARE_ATTESTED`
        :param str pub_file: A CSR or SSH public key to use instead of generating one.
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "type", type)
        if protection is not None:
            pulumi.set(__self__, "protection", protection)
        if pub_file is not None:
            pulumi.set(__self__, "pub_file", pub_file)

    @property
    @pulumi.getter
    def format(self) -> str:
        """
        The format used to encode the private key. For X509 keys the default format is PKCS#8. The classic format is PKCS#1 for RSA keys, SEC 1 for ECDSA keys, and PKCS#8 for ED25519 keys. For SSH keys the default format is always the OPENSSH format. When a hardware module is used to store the keys the default will be a JSON representation of the key, except on Linux where tss2 will be used. Allowed values: `DEFAULT` `PKCS8` `OPENSSH` `TSS2` `CLASSIC`
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The key type used. The current DEFAULT type is ECDSA_P256. Allowed values: `DEFAULT` `ECDSA_P256` `ECDSA_P384` `ECDSA_P521` `RSA_2048` `RSA_3072` `RSA_4096` `ED25519`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def protection(self) -> Optional[str]:
        """
        Whether to use a hardware module to store the private key for a workload certificate. If set to `NONE` no hardware module will be used. If set to `DEFAULT` a hardware module will only be used with format `TSS2`. `HARDWARE_WITH_FALLBACK` can only be used with the key format `DEFAULT`. Allowed values: `DEFAULT` `NONE` `HARDWARE` `HARDWARE_WITH_FALLBACK` `HARDWARE_ATTESTED`
        """
        return pulumi.get(self, "protection")

    @property
    @pulumi.getter(name="pubFile")
    def pub_file(self) -> Optional[str]:
        """
        A CSR or SSH public key to use instead of generating one.
        """
        return pulumi.get(self, "pub_file")


@pulumi.output_type
class WorkloadReloadInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pidFile":
            suggest = "pid_file"
        elif key == "unitName":
            suggest = "unit_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadReloadInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadReloadInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadReloadInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: str,
                 pid_file: Optional[str] = None,
                 signal: Optional[float] = None,
                 unit_name: Optional[str] = None):
        """
        :param str method: Ways an endpoint can reload a certificate. `AUTOMATIC` means the process is able to detect and reload new certificates automatically. `CUSTOM` means a custom command must be run to trigger the workload to reload the certificates. `SIGNAL` will configure the agent to send a signal to the process in `pidFile`. `DBUS` will use the systemd system bus to issue a `try-reload-or-restart` job for unit specified by `unitName`. `PLATFORM` uses a method specific to the operating system. Allowed values: `AUTOMATIC` `CUSTOM` `SIGNAL` `DBUS` `PLATFORM`
        :param str pid_file: File that holds the pid of the process to signal. Required when method is SIGNAL.
        :param float signal: The signal to send to a process when a certificate should be reloaded. Required when method is SIGNAL.
        :param str unit_name: The systemd unit name to reload when a certificate should be reloaded. Required when method is DBUS.
        """
        pulumi.set(__self__, "method", method)
        if pid_file is not None:
            pulumi.set(__self__, "pid_file", pid_file)
        if signal is not None:
            pulumi.set(__self__, "signal", signal)
        if unit_name is not None:
            pulumi.set(__self__, "unit_name", unit_name)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        Ways an endpoint can reload a certificate. `AUTOMATIC` means the process is able to detect and reload new certificates automatically. `CUSTOM` means a custom command must be run to trigger the workload to reload the certificates. `SIGNAL` will configure the agent to send a signal to the process in `pidFile`. `DBUS` will use the systemd system bus to issue a `try-reload-or-restart` job for unit specified by `unitName`. `PLATFORM` uses a method specific to the operating system. Allowed values: `AUTOMATIC` `CUSTOM` `SIGNAL` `DBUS` `PLATFORM`
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="pidFile")
    def pid_file(self) -> Optional[str]:
        """
        File that holds the pid of the process to signal. Required when method is SIGNAL.
        """
        return pulumi.get(self, "pid_file")

    @property
    @pulumi.getter
    def signal(self) -> Optional[float]:
        """
        The signal to send to a process when a certificate should be reloaded. Required when method is SIGNAL.
        """
        return pulumi.get(self, "signal")

    @property
    @pulumi.getter(name="unitName")
    def unit_name(self) -> Optional[str]:
        """
        The systemd unit name to reload when a certificate should be reloaded. Required when method is DBUS.
        """
        return pulumi.get(self, "unit_name")


@pulumi.output_type
class GetAccountBrowserResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetAccountEthernetResult(dict):
    def __init__(__self__, *,
                 autojoin: bool,
                 ca_chain: str,
                 external_radius_server: bool,
                 network_access_server_ip: str):
        pulumi.set(__self__, "autojoin", autojoin)
        pulumi.set(__self__, "ca_chain", ca_chain)
        pulumi.set(__self__, "external_radius_server", external_radius_server)
        pulumi.set(__self__, "network_access_server_ip", network_access_server_ip)

    @property
    @pulumi.getter
    def autojoin(self) -> bool:
        return pulumi.get(self, "autojoin")

    @property
    @pulumi.getter(name="caChain")
    def ca_chain(self) -> str:
        return pulumi.get(self, "ca_chain")

    @property
    @pulumi.getter(name="externalRadiusServer")
    def external_radius_server(self) -> bool:
        return pulumi.get(self, "external_radius_server")

    @property
    @pulumi.getter(name="networkAccessServerIp")
    def network_access_server_ip(self) -> str:
        return pulumi.get(self, "network_access_server_ip")


@pulumi.output_type
class GetAccountVpnResult(dict):
    def __init__(__self__, *,
                 autojoin: bool,
                 connection_type: str,
                 ike: 'outputs.GetAccountVpnIkeResult',
                 remote_address: str,
                 vendor: str):
        """
        :param str connection_type: Allowed values: `IPSec` `IKEv2` `SSL`
        :param str vendor: Allowed values: `F5` `Cisco` `Juniper`
        """
        pulumi.set(__self__, "autojoin", autojoin)
        pulumi.set(__self__, "connection_type", connection_type)
        pulumi.set(__self__, "ike", ike)
        pulumi.set(__self__, "remote_address", remote_address)
        pulumi.set(__self__, "vendor", vendor)

    @property
    @pulumi.getter
    def autojoin(self) -> bool:
        return pulumi.get(self, "autojoin")

    @property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> str:
        """
        Allowed values: `IPSec` `IKEv2` `SSL`
        """
        return pulumi.get(self, "connection_type")

    @property
    @pulumi.getter
    def ike(self) -> 'outputs.GetAccountVpnIkeResult':
        return pulumi.get(self, "ike")

    @property
    @pulumi.getter(name="remoteAddress")
    def remote_address(self) -> str:
        return pulumi.get(self, "remote_address")

    @property
    @pulumi.getter
    def vendor(self) -> str:
        """
        Allowed values: `F5` `Cisco` `Juniper`
        """
        return pulumi.get(self, "vendor")


@pulumi.output_type
class GetAccountVpnIkeResult(dict):
    def __init__(__self__, *,
                 ca_chain: str,
                 eap: bool,
                 remote_id: str):
        """
        :param str remote_id: Typically, the common name of the remote server. Defaults to the remote address.
        """
        pulumi.set(__self__, "ca_chain", ca_chain)
        pulumi.set(__self__, "eap", eap)
        pulumi.set(__self__, "remote_id", remote_id)

    @property
    @pulumi.getter(name="caChain")
    def ca_chain(self) -> str:
        return pulumi.get(self, "ca_chain")

    @property
    @pulumi.getter
    def eap(self) -> bool:
        return pulumi.get(self, "eap")

    @property
    @pulumi.getter(name="remoteId")
    def remote_id(self) -> str:
        """
        Typically, the common name of the remote server. Defaults to the remote address.
        """
        return pulumi.get(self, "remote_id")


@pulumi.output_type
class GetAccountWifiResult(dict):
    def __init__(__self__, *,
                 autojoin: bool,
                 ca_chain: str,
                 external_radius_server: bool,
                 hidden: bool,
                 network_access_server_ip: str,
                 ssid: str):
        pulumi.set(__self__, "autojoin", autojoin)
        pulumi.set(__self__, "ca_chain", ca_chain)
        pulumi.set(__self__, "external_radius_server", external_radius_server)
        pulumi.set(__self__, "hidden", hidden)
        pulumi.set(__self__, "network_access_server_ip", network_access_server_ip)
        pulumi.set(__self__, "ssid", ssid)

    @property
    @pulumi.getter
    def autojoin(self) -> bool:
        return pulumi.get(self, "autojoin")

    @property
    @pulumi.getter(name="caChain")
    def ca_chain(self) -> str:
        return pulumi.get(self, "ca_chain")

    @property
    @pulumi.getter(name="externalRadiusServer")
    def external_radius_server(self) -> bool:
        return pulumi.get(self, "external_radius_server")

    @property
    @pulumi.getter
    def hidden(self) -> bool:
        return pulumi.get(self, "hidden")

    @property
    @pulumi.getter(name="networkAccessServerIp")
    def network_access_server_ip(self) -> str:
        return pulumi.get(self, "network_access_server_ip")

    @property
    @pulumi.getter
    def ssid(self) -> str:
        return pulumi.get(self, "ssid")


@pulumi.output_type
class GetDeviceCollectionAccountCertificateDataResult(dict):
    def __init__(__self__, *,
                 common_name: Optional['outputs.GetDeviceCollectionAccountCertificateDataCommonNameResult'] = None,
                 country: Optional['outputs.GetDeviceCollectionAccountCertificateDataCountryResult'] = None,
                 locality: Optional['outputs.GetDeviceCollectionAccountCertificateDataLocalityResult'] = None,
                 organization: Optional['outputs.GetDeviceCollectionAccountCertificateDataOrganizationResult'] = None,
                 organizational_unit: Optional['outputs.GetDeviceCollectionAccountCertificateDataOrganizationalUnitResult'] = None,
                 postal_code: Optional['outputs.GetDeviceCollectionAccountCertificateDataPostalCodeResult'] = None,
                 province: Optional['outputs.GetDeviceCollectionAccountCertificateDataProvinceResult'] = None,
                 sans: Optional['outputs.GetDeviceCollectionAccountCertificateDataSansResult'] = None,
                 street_address: Optional['outputs.GetDeviceCollectionAccountCertificateDataStreetAddressResult'] = None):
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if locality is not None:
            pulumi.set(__self__, "locality", locality)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if organizational_unit is not None:
            pulumi.set(__self__, "organizational_unit", organizational_unit)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if province is not None:
            pulumi.set(__self__, "province", province)
        if sans is not None:
            pulumi.set(__self__, "sans", sans)
        if street_address is not None:
            pulumi.set(__self__, "street_address", street_address)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional['outputs.GetDeviceCollectionAccountCertificateDataCommonNameResult']:
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter
    def country(self) -> Optional['outputs.GetDeviceCollectionAccountCertificateDataCountryResult']:
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def locality(self) -> Optional['outputs.GetDeviceCollectionAccountCertificateDataLocalityResult']:
        return pulumi.get(self, "locality")

    @property
    @pulumi.getter
    def organization(self) -> Optional['outputs.GetDeviceCollectionAccountCertificateDataOrganizationResult']:
        return pulumi.get(self, "organization")

    @property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> Optional['outputs.GetDeviceCollectionAccountCertificateDataOrganizationalUnitResult']:
        return pulumi.get(self, "organizational_unit")

    @property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional['outputs.GetDeviceCollectionAccountCertificateDataPostalCodeResult']:
        return pulumi.get(self, "postal_code")

    @property
    @pulumi.getter
    def province(self) -> Optional['outputs.GetDeviceCollectionAccountCertificateDataProvinceResult']:
        return pulumi.get(self, "province")

    @property
    @pulumi.getter
    def sans(self) -> Optional['outputs.GetDeviceCollectionAccountCertificateDataSansResult']:
        return pulumi.get(self, "sans")

    @property
    @pulumi.getter(name="streetAddress")
    def street_address(self) -> Optional['outputs.GetDeviceCollectionAccountCertificateDataStreetAddressResult']:
        return pulumi.get(self, "street_address")


@pulumi.output_type
class GetDeviceCollectionAccountCertificateDataCommonNameResult(dict):
    def __init__(__self__, *,
                 device_metadata: Optional[str] = None,
                 static: Optional[str] = None):
        if device_metadata is not None:
            pulumi.set(__self__, "device_metadata", device_metadata)
        if static is not None:
            pulumi.set(__self__, "static", static)

    @property
    @pulumi.getter(name="deviceMetadata")
    def device_metadata(self) -> Optional[str]:
        return pulumi.get(self, "device_metadata")

    @property
    @pulumi.getter
    def static(self) -> Optional[str]:
        return pulumi.get(self, "static")


@pulumi.output_type
class GetDeviceCollectionAccountCertificateDataCountryResult(dict):
    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")


@pulumi.output_type
class GetDeviceCollectionAccountCertificateDataLocalityResult(dict):
    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")


@pulumi.output_type
class GetDeviceCollectionAccountCertificateDataOrganizationResult(dict):
    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")


@pulumi.output_type
class GetDeviceCollectionAccountCertificateDataOrganizationalUnitResult(dict):
    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")


@pulumi.output_type
class GetDeviceCollectionAccountCertificateDataPostalCodeResult(dict):
    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")


@pulumi.output_type
class GetDeviceCollectionAccountCertificateDataProvinceResult(dict):
    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")


@pulumi.output_type
class GetDeviceCollectionAccountCertificateDataSansResult(dict):
    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")


@pulumi.output_type
class GetDeviceCollectionAccountCertificateDataStreetAddressResult(dict):
    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")


@pulumi.output_type
class GetDeviceCollectionAccountCertificateInfoResult(dict):
    def __init__(__self__, *,
                 crt_file: Optional[str] = None,
                 duration: Optional[str] = None,
                 gid: Optional[float] = None,
                 key_file: Optional[str] = None,
                 mode: Optional[float] = None,
                 root_file: Optional[str] = None,
                 type: Optional[str] = None,
                 uid: Optional[float] = None):
        """
        :param str crt_file: The filepath where the certificate is to be stored.
        :param str duration: The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param float gid: GID of the files where the certificate is stored.
        :param str key_file: The filepath where the key is to be stored.
        :param float mode: Permission bits of the files where the certificate is stored.
        :param str root_file: The filepath where the root certificate is to be stored.
        :param str type: The type of certificate. Allowed values: `X509` `SSH_USER` `SSH_HOST`
        :param float uid: UID of the files where the certificate is stored.
        """
        if crt_file is not None:
            pulumi.set(__self__, "crt_file", crt_file)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if gid is not None:
            pulumi.set(__self__, "gid", gid)
        if key_file is not None:
            pulumi.set(__self__, "key_file", key_file)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if root_file is not None:
            pulumi.set(__self__, "root_file", root_file)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="crtFile")
    def crt_file(self) -> Optional[str]:
        """
        The filepath where the certificate is to be stored.
        """
        return pulumi.get(self, "crt_file")

    @property
    @pulumi.getter
    def duration(self) -> Optional[str]:
        """
        The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def gid(self) -> Optional[float]:
        """
        GID of the files where the certificate is stored.
        """
        return pulumi.get(self, "gid")

    @property
    @pulumi.getter(name="keyFile")
    def key_file(self) -> Optional[str]:
        """
        The filepath where the key is to be stored.
        """
        return pulumi.get(self, "key_file")

    @property
    @pulumi.getter
    def mode(self) -> Optional[float]:
        """
        Permission bits of the files where the certificate is stored.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="rootFile")
    def root_file(self) -> Optional[str]:
        """
        The filepath where the root certificate is to be stored.
        """
        return pulumi.get(self, "root_file")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of certificate. Allowed values: `X509` `SSH_USER` `SSH_HOST`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def uid(self) -> Optional[float]:
        """
        UID of the files where the certificate is stored.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class GetDeviceCollectionAccountKeyInfoResult(dict):
    def __init__(__self__, *,
                 format: Optional[str] = None,
                 protection: Optional[str] = None,
                 pub_file: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str format: The format used to encode the private key. For X509 keys the default format is PKCS#8. The classic format is PKCS#1 for RSA keys, SEC 1 for ECDSA keys, and PKCS#8 for ED25519 keys. For SSH keys the default format is always the OPENSSH format. When a hardware module is used to store the keys the default will be a JSON representation of the key, except on Linux where tss2 will be used. Allowed values: `DEFAULT` `PKCS8` `OPENSSH` `TSS2` `CLASSIC`
        :param str protection: Whether to use a hardware module to store the private key for a workload certificate. If set to `NONE` no hardware module will be used. If set to `DEFAULT` a hardware module will only be used with format `TSS2`. `HARDWARE_WITH_FALLBACK` can only be used with the key format `DEFAULT`. Allowed values: `DEFAULT` `NONE` `HARDWARE` `HARDWARE_WITH_FALLBACK` `HARDWARE_ATTESTED`
        :param str pub_file: A CSR or SSH public key to use instead of generating one.
        :param str type: The key type used. The current DEFAULT type is ECDSA_P256. Allowed values: `DEFAULT` `ECDSA_P256` `ECDSA_P384` `ECDSA_P521` `RSA_2048` `RSA_3072` `RSA_4096` `ED25519`
        """
        if format is not None:
            pulumi.set(__self__, "format", format)
        if protection is not None:
            pulumi.set(__self__, "protection", protection)
        if pub_file is not None:
            pulumi.set(__self__, "pub_file", pub_file)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def format(self) -> Optional[str]:
        """
        The format used to encode the private key. For X509 keys the default format is PKCS#8. The classic format is PKCS#1 for RSA keys, SEC 1 for ECDSA keys, and PKCS#8 for ED25519 keys. For SSH keys the default format is always the OPENSSH format. When a hardware module is used to store the keys the default will be a JSON representation of the key, except on Linux where tss2 will be used. Allowed values: `DEFAULT` `PKCS8` `OPENSSH` `TSS2` `CLASSIC`
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def protection(self) -> Optional[str]:
        """
        Whether to use a hardware module to store the private key for a workload certificate. If set to `NONE` no hardware module will be used. If set to `DEFAULT` a hardware module will only be used with format `TSS2`. `HARDWARE_WITH_FALLBACK` can only be used with the key format `DEFAULT`. Allowed values: `DEFAULT` `NONE` `HARDWARE` `HARDWARE_WITH_FALLBACK` `HARDWARE_ATTESTED`
        """
        return pulumi.get(self, "protection")

    @property
    @pulumi.getter(name="pubFile")
    def pub_file(self) -> Optional[str]:
        """
        A CSR or SSH public key to use instead of generating one.
        """
        return pulumi.get(self, "pub_file")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The key type used. The current DEFAULT type is ECDSA_P256. Allowed values: `DEFAULT` `ECDSA_P256` `ECDSA_P384` `ECDSA_P521` `RSA_2048` `RSA_3072` `RSA_4096` `ED25519`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDeviceCollectionAccountReloadInfoResult(dict):
    def __init__(__self__, *,
                 method: Optional[str] = None,
                 pid_file: Optional[str] = None,
                 signal: Optional[float] = None,
                 unit_name: Optional[str] = None):
        """
        :param str method: Ways an endpoint can reload a certificate. `AUTOMATIC` means the process is able to detect and reload new certificates automatically. `CUSTOM` means a custom command must be run to trigger the workload to reload the certificates. `SIGNAL` will configure the agent to send a signal to the process in `pidFile`. `DBUS` will use the systemd system bus to issue a `try-reload-or-restart` job for unit specified by `unitName`. `PLATFORM` uses a method specific to the operating system. Allowed values: `AUTOMATIC` `CUSTOM` `SIGNAL` `DBUS` `PLATFORM`
        :param str pid_file: File that holds the pid of the process to signal. Required when method is SIGNAL.
        :param float signal: The signal to send to a process when a certificate should be reloaded. Required when method is SIGNAL.
        :param str unit_name: The systemd unit name to reload when a certificate should be reloaded. Required when method is DBUS.
        """
        if method is not None:
            pulumi.set(__self__, "method", method)
        if pid_file is not None:
            pulumi.set(__self__, "pid_file", pid_file)
        if signal is not None:
            pulumi.set(__self__, "signal", signal)
        if unit_name is not None:
            pulumi.set(__self__, "unit_name", unit_name)

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        Ways an endpoint can reload a certificate. `AUTOMATIC` means the process is able to detect and reload new certificates automatically. `CUSTOM` means a custom command must be run to trigger the workload to reload the certificates. `SIGNAL` will configure the agent to send a signal to the process in `pidFile`. `DBUS` will use the systemd system bus to issue a `try-reload-or-restart` job for unit specified by `unitName`. `PLATFORM` uses a method specific to the operating system. Allowed values: `AUTOMATIC` `CUSTOM` `SIGNAL` `DBUS` `PLATFORM`
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="pidFile")
    def pid_file(self) -> Optional[str]:
        """
        File that holds the pid of the process to signal. Required when method is SIGNAL.
        """
        return pulumi.get(self, "pid_file")

    @property
    @pulumi.getter
    def signal(self) -> Optional[float]:
        """
        The signal to send to a process when a certificate should be reloaded. Required when method is SIGNAL.
        """
        return pulumi.get(self, "signal")

    @property
    @pulumi.getter(name="unitName")
    def unit_name(self) -> Optional[str]:
        """
        The systemd unit name to reload when a certificate should be reloaded. Required when method is DBUS.
        """
        return pulumi.get(self, "unit_name")


@pulumi.output_type
class GetProvisionerAcmeResult(dict):
    def __init__(__self__, *,
                 challenges: Sequence[str],
                 force_cn: bool,
                 require_eab: bool):
        """
        :param Sequence[str] challenges: Which ACME challenge types are allowed. Allowed values: `http-01` `dns-01` `tls-alpn-01`
        :param bool force_cn: Force one of the SANs to become the Common Name, if a Common Name is not provided.
        :param bool require_eab: Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner. Must be `true` for all new provisioners.
        """
        pulumi.set(__self__, "challenges", challenges)
        pulumi.set(__self__, "force_cn", force_cn)
        pulumi.set(__self__, "require_eab", require_eab)

    @property
    @pulumi.getter
    def challenges(self) -> Sequence[str]:
        """
        Which ACME challenge types are allowed. Allowed values: `http-01` `dns-01` `tls-alpn-01`
        """
        return pulumi.get(self, "challenges")

    @property
    @pulumi.getter(name="forceCn")
    def force_cn(self) -> bool:
        """
        Force one of the SANs to become the Common Name, if a Common Name is not provided.
        """
        return pulumi.get(self, "force_cn")

    @property
    @pulumi.getter(name="requireEab")
    def require_eab(self) -> bool:
        """
        Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner. Must be `true` for all new provisioners.
        """
        return pulumi.get(self, "require_eab")


@pulumi.output_type
class GetProvisionerAcmeAttestationResult(dict):
    def __init__(__self__, *,
                 attestation_formats: Sequence[str],
                 attestation_roots: Sequence[str],
                 force_cn: bool,
                 require_eab: bool):
        """
        :param Sequence[str] attestation_formats: The allowed attestation formats for the device-attest-01 challenge. Valid values are `apple`, `step`, and `tpm`. The apple format is for Apple devices, and adds trust for Apple's CAs. The step format is for non-TPM devices that can issue attestation certificates, such as YubiKey PIV. It adds trust for Yubico's root CA. The tpm format is for TPMs and does not trust any CAs by default. Allowed values: `apple` `step` `tpm`
        :param Sequence[str] attestation_roots: A trust bundle of root certificates in PEM format that will be used to verify attestation certificates. The default value depends on the value of attestationFormats. If provided, this PEM bundle will override the CA trust established by setting attestationFormats to apple or step. At least one root certificate is required when using the tpm attestationFormat.
        :param bool force_cn: Force one of the SANs to become the Common Name, if a Common Name is not provided.
        :param bool require_eab: Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner.
        """
        pulumi.set(__self__, "attestation_formats", attestation_formats)
        pulumi.set(__self__, "attestation_roots", attestation_roots)
        pulumi.set(__self__, "force_cn", force_cn)
        pulumi.set(__self__, "require_eab", require_eab)

    @property
    @pulumi.getter(name="attestationFormats")
    def attestation_formats(self) -> Sequence[str]:
        """
        The allowed attestation formats for the device-attest-01 challenge. Valid values are `apple`, `step`, and `tpm`. The apple format is for Apple devices, and adds trust for Apple's CAs. The step format is for non-TPM devices that can issue attestation certificates, such as YubiKey PIV. It adds trust for Yubico's root CA. The tpm format is for TPMs and does not trust any CAs by default. Allowed values: `apple` `step` `tpm`
        """
        return pulumi.get(self, "attestation_formats")

    @property
    @pulumi.getter(name="attestationRoots")
    def attestation_roots(self) -> Sequence[str]:
        """
        A trust bundle of root certificates in PEM format that will be used to verify attestation certificates. The default value depends on the value of attestationFormats. If provided, this PEM bundle will override the CA trust established by setting attestationFormats to apple or step. At least one root certificate is required when using the tpm attestationFormat.
        """
        return pulumi.get(self, "attestation_roots")

    @property
    @pulumi.getter(name="forceCn")
    def force_cn(self) -> bool:
        """
        Force one of the SANs to become the Common Name, if a Common Name is not provided.
        """
        return pulumi.get(self, "force_cn")

    @property
    @pulumi.getter(name="requireEab")
    def require_eab(self) -> bool:
        """
        Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner.
        """
        return pulumi.get(self, "require_eab")


@pulumi.output_type
class GetProvisionerAwsResult(dict):
    def __init__(__self__, *,
                 accounts: Sequence[str],
                 disable_custom_sans: bool,
                 disable_trust_on_first_use: bool,
                 instance_age: str):
        """
        :param Sequence[str] accounts: The list of AWS account IDs that are allowed to use an AWS cloud provisioner.
        :param bool disable_custom_sans: By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid. These are the private IP and the DNS ip-<private-ip>.<region>.compute.internal.
        :param bool disable_trust_on_first_use: By default only one certificate will be granted per instance, but if the option is set to `true` this limit is not set and different tokens can be used to get different certificates.
        :param str instance_age: The maximum age of an instance that should be allowed to obtain a certificate. Limits certificate issuance to new instances to mitigate the risk of credential-misuse from instances that don't need a certificate. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        pulumi.set(__self__, "accounts", accounts)
        pulumi.set(__self__, "disable_custom_sans", disable_custom_sans)
        pulumi.set(__self__, "disable_trust_on_first_use", disable_trust_on_first_use)
        pulumi.set(__self__, "instance_age", instance_age)

    @property
    @pulumi.getter
    def accounts(self) -> Sequence[str]:
        """
        The list of AWS account IDs that are allowed to use an AWS cloud provisioner.
        """
        return pulumi.get(self, "accounts")

    @property
    @pulumi.getter(name="disableCustomSans")
    def disable_custom_sans(self) -> bool:
        """
        By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid. These are the private IP and the DNS ip-<private-ip>.<region>.compute.internal.
        """
        return pulumi.get(self, "disable_custom_sans")

    @property
    @pulumi.getter(name="disableTrustOnFirstUse")
    def disable_trust_on_first_use(self) -> bool:
        """
        By default only one certificate will be granted per instance, but if the option is set to `true` this limit is not set and different tokens can be used to get different certificates.
        """
        return pulumi.get(self, "disable_trust_on_first_use")

    @property
    @pulumi.getter(name="instanceAge")
    def instance_age(self) -> str:
        """
        The maximum age of an instance that should be allowed to obtain a certificate. Limits certificate issuance to new instances to mitigate the risk of credential-misuse from instances that don't need a certificate. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "instance_age")


@pulumi.output_type
class GetProvisionerAzureResult(dict):
    def __init__(__self__, *,
                 audience: str,
                 disable_custom_sans: bool,
                 disable_trust_on_first_use: bool,
                 resource_groups: Sequence[str],
                 tenant_id: str):
        """
        :param str audience: Defaults to https://management.azure.com/ but it can be changed if necessary.
        :param bool disable_custom_sans: By default custom SANs are valid, but if this option is set to `true` only the SANs available in the token will be valid, in Azure only the virtual machine name is available.
        :param bool disable_trust_on_first_use: By default only one certificate will be granted per instance, but if the option is set to true this limit is not set and different tokens can be used to get different certificates.
        :param Sequence[str] resource_groups: The list of resource group names that are allowed to use this provisioner.
        :param str tenant_id: The Azure account tenant ID for this provisioner. This ID is the Directory ID available in the Azure Active Directory properties.
        """
        pulumi.set(__self__, "audience", audience)
        pulumi.set(__self__, "disable_custom_sans", disable_custom_sans)
        pulumi.set(__self__, "disable_trust_on_first_use", disable_trust_on_first_use)
        pulumi.set(__self__, "resource_groups", resource_groups)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def audience(self) -> str:
        """
        Defaults to https://management.azure.com/ but it can be changed if necessary.
        """
        return pulumi.get(self, "audience")

    @property
    @pulumi.getter(name="disableCustomSans")
    def disable_custom_sans(self) -> bool:
        """
        By default custom SANs are valid, but if this option is set to `true` only the SANs available in the token will be valid, in Azure only the virtual machine name is available.
        """
        return pulumi.get(self, "disable_custom_sans")

    @property
    @pulumi.getter(name="disableTrustOnFirstUse")
    def disable_trust_on_first_use(self) -> bool:
        """
        By default only one certificate will be granted per instance, but if the option is set to true this limit is not set and different tokens can be used to get different certificates.
        """
        return pulumi.get(self, "disable_trust_on_first_use")

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Sequence[str]:
        """
        The list of resource group names that are allowed to use this provisioner.
        """
        return pulumi.get(self, "resource_groups")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The Azure account tenant ID for this provisioner. This ID is the Directory ID available in the Azure Active Directory properties.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetProvisionerClaimsResult(dict):
    def __init__(__self__, *,
                 allow_renewal_after_expiry: bool,
                 default_host_ssh_cert_duration: str,
                 default_tls_cert_duration: str,
                 default_user_ssh_cert_duration: str,
                 disable_renewal: bool,
                 enable_ssh_ca: bool,
                 max_host_ssh_cert_duration: str,
                 max_tls_cert_duration: str,
                 max_user_ssh_cert_duration: str,
                 min_host_ssh_cert_duration: str,
                 min_tls_cert_duration: str,
                 min_user_ssh_cert_duration: str):
        """
        :param bool allow_renewal_after_expiry: Allow renewals for expired certificates generated by this provisioner.
        :param str default_host_ssh_cert_duration: The default duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param str default_tls_cert_duration: The default duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param str default_user_ssh_cert_duration: The default duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param bool disable_renewal: Disable renewal for all certificates generated by this provisioner.
        :param bool enable_ssh_ca: Allow this provisioner to be used to generate SSH certificates.
        :param str max_host_ssh_cert_duration: The maximum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param str max_tls_cert_duration: The maximum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param str max_user_ssh_cert_duration: The maximum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param str min_host_ssh_cert_duration: The minimum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param str min_tls_cert_duration: The minimum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param str min_user_ssh_cert_duration: The minimum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        pulumi.set(__self__, "allow_renewal_after_expiry", allow_renewal_after_expiry)
        pulumi.set(__self__, "default_host_ssh_cert_duration", default_host_ssh_cert_duration)
        pulumi.set(__self__, "default_tls_cert_duration", default_tls_cert_duration)
        pulumi.set(__self__, "default_user_ssh_cert_duration", default_user_ssh_cert_duration)
        pulumi.set(__self__, "disable_renewal", disable_renewal)
        pulumi.set(__self__, "enable_ssh_ca", enable_ssh_ca)
        pulumi.set(__self__, "max_host_ssh_cert_duration", max_host_ssh_cert_duration)
        pulumi.set(__self__, "max_tls_cert_duration", max_tls_cert_duration)
        pulumi.set(__self__, "max_user_ssh_cert_duration", max_user_ssh_cert_duration)
        pulumi.set(__self__, "min_host_ssh_cert_duration", min_host_ssh_cert_duration)
        pulumi.set(__self__, "min_tls_cert_duration", min_tls_cert_duration)
        pulumi.set(__self__, "min_user_ssh_cert_duration", min_user_ssh_cert_duration)

    @property
    @pulumi.getter(name="allowRenewalAfterExpiry")
    def allow_renewal_after_expiry(self) -> bool:
        """
        Allow renewals for expired certificates generated by this provisioner.
        """
        return pulumi.get(self, "allow_renewal_after_expiry")

    @property
    @pulumi.getter(name="defaultHostSshCertDuration")
    def default_host_ssh_cert_duration(self) -> str:
        """
        The default duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "default_host_ssh_cert_duration")

    @property
    @pulumi.getter(name="defaultTlsCertDuration")
    def default_tls_cert_duration(self) -> str:
        """
        The default duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "default_tls_cert_duration")

    @property
    @pulumi.getter(name="defaultUserSshCertDuration")
    def default_user_ssh_cert_duration(self) -> str:
        """
        The default duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "default_user_ssh_cert_duration")

    @property
    @pulumi.getter(name="disableRenewal")
    def disable_renewal(self) -> bool:
        """
        Disable renewal for all certificates generated by this provisioner.
        """
        return pulumi.get(self, "disable_renewal")

    @property
    @pulumi.getter(name="enableSshCa")
    def enable_ssh_ca(self) -> bool:
        """
        Allow this provisioner to be used to generate SSH certificates.
        """
        return pulumi.get(self, "enable_ssh_ca")

    @property
    @pulumi.getter(name="maxHostSshCertDuration")
    def max_host_ssh_cert_duration(self) -> str:
        """
        The maximum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "max_host_ssh_cert_duration")

    @property
    @pulumi.getter(name="maxTlsCertDuration")
    def max_tls_cert_duration(self) -> str:
        """
        The maximum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "max_tls_cert_duration")

    @property
    @pulumi.getter(name="maxUserSshCertDuration")
    def max_user_ssh_cert_duration(self) -> str:
        """
        The maximum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "max_user_ssh_cert_duration")

    @property
    @pulumi.getter(name="minHostSshCertDuration")
    def min_host_ssh_cert_duration(self) -> str:
        """
        The minimum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "min_host_ssh_cert_duration")

    @property
    @pulumi.getter(name="minTlsCertDuration")
    def min_tls_cert_duration(self) -> str:
        """
        The minimum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "min_tls_cert_duration")

    @property
    @pulumi.getter(name="minUserSshCertDuration")
    def min_user_ssh_cert_duration(self) -> str:
        """
        The minimum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "min_user_ssh_cert_duration")


@pulumi.output_type
class GetProvisionerGcpResult(dict):
    def __init__(__self__, *,
                 disable_custom_sans: bool,
                 disable_trust_on_first_use: bool,
                 instance_age: str,
                 project_ids: Sequence[str],
                 service_accounts: Sequence[str]):
        """
        :param bool disable_custom_sans: By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid, these are the DNS `<instance-name>.c.<project-id>.internal` and `<instance-name>.<zone>.c.<project-id>.internal`.
        :param bool disable_trust_on_first_use: By default only one certificate will be granted per instance, but if the option is set to `true` this limit is not set and different tokens can be used to get different certificates.
        :param str instance_age: The maximum age of an instance that should be allowed to obtain a certificate. Limits certificate issuance to new instances to mitigate the risk of credential-misuse from instances that don't need a certificate. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param Sequence[str] project_ids: The list of project identifiers that are allowed to use a GCP cloud provisioner.
        :param Sequence[str] service_accounts: The list of service accounts that are allowed to use a GCP cloud provisioner.
        """
        pulumi.set(__self__, "disable_custom_sans", disable_custom_sans)
        pulumi.set(__self__, "disable_trust_on_first_use", disable_trust_on_first_use)
        pulumi.set(__self__, "instance_age", instance_age)
        pulumi.set(__self__, "project_ids", project_ids)
        pulumi.set(__self__, "service_accounts", service_accounts)

    @property
    @pulumi.getter(name="disableCustomSans")
    def disable_custom_sans(self) -> bool:
        """
        By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid, these are the DNS `<instance-name>.c.<project-id>.internal` and `<instance-name>.<zone>.c.<project-id>.internal`.
        """
        return pulumi.get(self, "disable_custom_sans")

    @property
    @pulumi.getter(name="disableTrustOnFirstUse")
    def disable_trust_on_first_use(self) -> bool:
        """
        By default only one certificate will be granted per instance, but if the option is set to `true` this limit is not set and different tokens can be used to get different certificates.
        """
        return pulumi.get(self, "disable_trust_on_first_use")

    @property
    @pulumi.getter(name="instanceAge")
    def instance_age(self) -> str:
        """
        The maximum age of an instance that should be allowed to obtain a certificate. Limits certificate issuance to new instances to mitigate the risk of credential-misuse from instances that don't need a certificate. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "instance_age")

    @property
    @pulumi.getter(name="projectIds")
    def project_ids(self) -> Sequence[str]:
        """
        The list of project identifiers that are allowed to use a GCP cloud provisioner.
        """
        return pulumi.get(self, "project_ids")

    @property
    @pulumi.getter(name="serviceAccounts")
    def service_accounts(self) -> Sequence[str]:
        """
        The list of service accounts that are allowed to use a GCP cloud provisioner.
        """
        return pulumi.get(self, "service_accounts")


@pulumi.output_type
class GetProvisionerJwkResult(dict):
    def __init__(__self__, *,
                 encrypted_key: str,
                 key: str):
        """
        :param str encrypted_key: The JWE encrypted private key.
        :param str key: The public JSON web key.
        """
        pulumi.set(__self__, "encrypted_key", encrypted_key)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter(name="encryptedKey")
    def encrypted_key(self) -> str:
        """
        The JWE encrypted private key.
        """
        return pulumi.get(self, "encrypted_key")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The public JSON web key.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class GetProvisionerOidcResult(dict):
    def __init__(__self__, *,
                 admins: Sequence[str],
                 client_id: str,
                 client_secret: str,
                 configuration_endpoint: str,
                 domains: Sequence[str],
                 groups: Sequence[str],
                 listen_address: str,
                 tenant_id: str):
        """
        :param Sequence[str] admins: The emails of admin users in an OpenID Connect provisioner. These users will not have restrictions in the certificates to sign.
        :param str client_id: The id used to validate the audience in an OpenID Connect token.
        :param str client_secret: The secret used to obtain the OpenID Connect tokens.
        :param str configuration_endpoint: OpenID Connect configuration URL.
        :param Sequence[str] domains: The domains used to validate the email claim in an OpenID Connect provisioner.
        :param Sequence[str] groups: The group list used to validate the groups extension in an OpenID Connect token.
        :param str listen_address: The callback address used in the OpenID Connect flow.
        :param str tenant_id: The tenant-id used to replace the templatized tenantid value in the OpenID Configuration.
        """
        pulumi.set(__self__, "admins", admins)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "configuration_endpoint", configuration_endpoint)
        pulumi.set(__self__, "domains", domains)
        pulumi.set(__self__, "groups", groups)
        pulumi.set(__self__, "listen_address", listen_address)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def admins(self) -> Sequence[str]:
        """
        The emails of admin users in an OpenID Connect provisioner. These users will not have restrictions in the certificates to sign.
        """
        return pulumi.get(self, "admins")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The id used to validate the audience in an OpenID Connect token.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The secret used to obtain the OpenID Connect tokens.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="configurationEndpoint")
    def configuration_endpoint(self) -> str:
        """
        OpenID Connect configuration URL.
        """
        return pulumi.get(self, "configuration_endpoint")

    @property
    @pulumi.getter
    def domains(self) -> Sequence[str]:
        """
        The domains used to validate the email claim in an OpenID Connect provisioner.
        """
        return pulumi.get(self, "domains")

    @property
    @pulumi.getter
    def groups(self) -> Sequence[str]:
        """
        The group list used to validate the groups extension in an OpenID Connect token.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter(name="listenAddress")
    def listen_address(self) -> str:
        """
        The callback address used in the OpenID Connect flow.
        """
        return pulumi.get(self, "listen_address")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant-id used to replace the templatized tenantid value in the OpenID Configuration.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetProvisionerOptionsResult(dict):
    def __init__(__self__, *,
                 ssh: 'outputs.GetProvisionerOptionsSshResult',
                 x509: 'outputs.GetProvisionerOptionsX509Result'):
        """
        :param 'GetProvisionerOptionsSshArgs' ssh: Options that apply when issuing SSH certificates
        :param 'GetProvisionerOptionsX509Args' x509: Options that apply when issuing x509 certificates.
        """
        pulumi.set(__self__, "ssh", ssh)
        pulumi.set(__self__, "x509", x509)

    @property
    @pulumi.getter
    def ssh(self) -> 'outputs.GetProvisionerOptionsSshResult':
        """
        Options that apply when issuing SSH certificates
        """
        return pulumi.get(self, "ssh")

    @property
    @pulumi.getter
    def x509(self) -> 'outputs.GetProvisionerOptionsX509Result':
        """
        Options that apply when issuing x509 certificates.
        """
        return pulumi.get(self, "x509")


@pulumi.output_type
class GetProvisionerOptionsSshResult(dict):
    def __init__(__self__, *,
                 template: str,
                 template_data: str):
        """
        :param str template: A JSON representation of the SSH certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#ssh-templates).
        :param str template_data: A map of data that can be used by the certificate template.
        """
        pulumi.set(__self__, "template", template)
        pulumi.set(__self__, "template_data", template_data)

    @property
    @pulumi.getter
    def template(self) -> str:
        """
        A JSON representation of the SSH certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#ssh-templates).
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter(name="templateData")
    def template_data(self) -> str:
        """
        A map of data that can be used by the certificate template.
        """
        return pulumi.get(self, "template_data")


@pulumi.output_type
class GetProvisionerOptionsX509Result(dict):
    def __init__(__self__, *,
                 template: str,
                 template_data: str):
        """
        :param str template: A JSON representation of the x509 certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#x509-templates).
        :param str template_data: A map of data that can be used by the certificate template.
        """
        pulumi.set(__self__, "template", template)
        pulumi.set(__self__, "template_data", template_data)

    @property
    @pulumi.getter
    def template(self) -> str:
        """
        A JSON representation of the x509 certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#x509-templates).
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter(name="templateData")
    def template_data(self) -> str:
        """
        A map of data that can be used by the certificate template.
        """
        return pulumi.get(self, "template_data")


@pulumi.output_type
class GetProvisionerX5cResult(dict):
    def __init__(__self__, *,
                 roots: Sequence[str]):
        """
        :param Sequence[str] roots: A list of pem-encoded x509 certificates. Any certificate bundle that chains up to any of these roots can be used in a certificate request.
        """
        pulumi.set(__self__, "roots", roots)

    @property
    @pulumi.getter
    def roots(self) -> Sequence[str]:
        """
        A list of pem-encoded x509 certificates. Any certificate bundle that chains up to any of these roots can be used in a certificate request.
        """
        return pulumi.get(self, "roots")


