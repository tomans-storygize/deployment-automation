# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'AccountBrowserArgs',
    'AccountBrowserArgsDict',
    'AccountEthernetArgs',
    'AccountEthernetArgsDict',
    'AccountVpnArgs',
    'AccountVpnArgsDict',
    'AccountVpnIkeArgs',
    'AccountVpnIkeArgsDict',
    'AccountWifiArgs',
    'AccountWifiArgsDict',
    'AuthorityIntermediateIssuerArgs',
    'AuthorityIntermediateIssuerArgsDict',
    'AuthorityIntermediateIssuerNameConstraintsArgs',
    'AuthorityIntermediateIssuerNameConstraintsArgsDict',
    'AuthorityIntermediateIssuerSubjectArgs',
    'AuthorityIntermediateIssuerSubjectArgsDict',
    'AuthorityRootIssuerArgs',
    'AuthorityRootIssuerArgsDict',
    'AuthorityRootIssuerNameConstraintsArgs',
    'AuthorityRootIssuerNameConstraintsArgsDict',
    'AuthorityRootIssuerSubjectArgs',
    'AuthorityRootIssuerSubjectArgsDict',
    'DeviceCollectionAccountCertificateDataArgs',
    'DeviceCollectionAccountCertificateDataArgsDict',
    'DeviceCollectionAccountCertificateDataCommonNameArgs',
    'DeviceCollectionAccountCertificateDataCommonNameArgsDict',
    'DeviceCollectionAccountCertificateDataCountryArgs',
    'DeviceCollectionAccountCertificateDataCountryArgsDict',
    'DeviceCollectionAccountCertificateDataLocalityArgs',
    'DeviceCollectionAccountCertificateDataLocalityArgsDict',
    'DeviceCollectionAccountCertificateDataOrganizationArgs',
    'DeviceCollectionAccountCertificateDataOrganizationArgsDict',
    'DeviceCollectionAccountCertificateDataOrganizationalUnitArgs',
    'DeviceCollectionAccountCertificateDataOrganizationalUnitArgsDict',
    'DeviceCollectionAccountCertificateDataPostalCodeArgs',
    'DeviceCollectionAccountCertificateDataPostalCodeArgsDict',
    'DeviceCollectionAccountCertificateDataProvinceArgs',
    'DeviceCollectionAccountCertificateDataProvinceArgsDict',
    'DeviceCollectionAccountCertificateDataSansArgs',
    'DeviceCollectionAccountCertificateDataSansArgsDict',
    'DeviceCollectionAccountCertificateDataStreetAddressArgs',
    'DeviceCollectionAccountCertificateDataStreetAddressArgsDict',
    'DeviceCollectionAccountCertificateInfoArgs',
    'DeviceCollectionAccountCertificateInfoArgsDict',
    'DeviceCollectionAccountKeyInfoArgs',
    'DeviceCollectionAccountKeyInfoArgsDict',
    'DeviceCollectionAccountReloadInfoArgs',
    'DeviceCollectionAccountReloadInfoArgsDict',
    'DeviceCollectionAwsVmArgs',
    'DeviceCollectionAwsVmArgsDict',
    'DeviceCollectionAzureVmArgs',
    'DeviceCollectionAzureVmArgsDict',
    'DeviceCollectionGcpVmArgs',
    'DeviceCollectionGcpVmArgsDict',
    'DeviceCollectionTpmArgs',
    'DeviceCollectionTpmArgsDict',
    'ProviderClientCertificateArgs',
    'ProviderClientCertificateArgsDict',
    'ProvisionerAcmeArgs',
    'ProvisionerAcmeArgsDict',
    'ProvisionerAcmeAttestationArgs',
    'ProvisionerAcmeAttestationArgsDict',
    'ProvisionerAwsArgs',
    'ProvisionerAwsArgsDict',
    'ProvisionerAzureArgs',
    'ProvisionerAzureArgsDict',
    'ProvisionerClaimsArgs',
    'ProvisionerClaimsArgsDict',
    'ProvisionerGcpArgs',
    'ProvisionerGcpArgsDict',
    'ProvisionerJwkArgs',
    'ProvisionerJwkArgsDict',
    'ProvisionerOidcArgs',
    'ProvisionerOidcArgsDict',
    'ProvisionerOptionsArgs',
    'ProvisionerOptionsArgsDict',
    'ProvisionerOptionsSshArgs',
    'ProvisionerOptionsSshArgsDict',
    'ProvisionerOptionsX509Args',
    'ProvisionerOptionsX509ArgsDict',
    'ProvisionerWebhookBasicAuthArgs',
    'ProvisionerWebhookBasicAuthArgsDict',
    'ProvisionerX5cArgs',
    'ProvisionerX5cArgsDict',
    'WorkloadCertificateDataArgs',
    'WorkloadCertificateDataArgsDict',
    'WorkloadCertificateDataCommonNameArgs',
    'WorkloadCertificateDataCommonNameArgsDict',
    'WorkloadCertificateDataCountryArgs',
    'WorkloadCertificateDataCountryArgsDict',
    'WorkloadCertificateDataLocalityArgs',
    'WorkloadCertificateDataLocalityArgsDict',
    'WorkloadCertificateDataOrganizationArgs',
    'WorkloadCertificateDataOrganizationArgsDict',
    'WorkloadCertificateDataOrganizationalUnitArgs',
    'WorkloadCertificateDataOrganizationalUnitArgsDict',
    'WorkloadCertificateDataPostalCodeArgs',
    'WorkloadCertificateDataPostalCodeArgsDict',
    'WorkloadCertificateDataProvinceArgs',
    'WorkloadCertificateDataProvinceArgsDict',
    'WorkloadCertificateDataSansArgs',
    'WorkloadCertificateDataSansArgsDict',
    'WorkloadCertificateDataStreetAddressArgs',
    'WorkloadCertificateDataStreetAddressArgsDict',
    'WorkloadCertificateInfoArgs',
    'WorkloadCertificateInfoArgsDict',
    'WorkloadHooksArgs',
    'WorkloadHooksArgsDict',
    'WorkloadHooksRenewArgs',
    'WorkloadHooksRenewArgsDict',
    'WorkloadHooksSignArgs',
    'WorkloadHooksSignArgsDict',
    'WorkloadKeyInfoArgs',
    'WorkloadKeyInfoArgsDict',
    'WorkloadReloadInfoArgs',
    'WorkloadReloadInfoArgsDict',
    'GetDeviceCollectionAccountCertificateDataArgs',
    'GetDeviceCollectionAccountCertificateDataArgsDict',
    'GetDeviceCollectionAccountCertificateDataCommonNameArgs',
    'GetDeviceCollectionAccountCertificateDataCommonNameArgsDict',
    'GetDeviceCollectionAccountCertificateDataCountryArgs',
    'GetDeviceCollectionAccountCertificateDataCountryArgsDict',
    'GetDeviceCollectionAccountCertificateDataLocalityArgs',
    'GetDeviceCollectionAccountCertificateDataLocalityArgsDict',
    'GetDeviceCollectionAccountCertificateDataOrganizationArgs',
    'GetDeviceCollectionAccountCertificateDataOrganizationArgsDict',
    'GetDeviceCollectionAccountCertificateDataOrganizationalUnitArgs',
    'GetDeviceCollectionAccountCertificateDataOrganizationalUnitArgsDict',
    'GetDeviceCollectionAccountCertificateDataPostalCodeArgs',
    'GetDeviceCollectionAccountCertificateDataPostalCodeArgsDict',
    'GetDeviceCollectionAccountCertificateDataProvinceArgs',
    'GetDeviceCollectionAccountCertificateDataProvinceArgsDict',
    'GetDeviceCollectionAccountCertificateDataSansArgs',
    'GetDeviceCollectionAccountCertificateDataSansArgsDict',
    'GetDeviceCollectionAccountCertificateDataStreetAddressArgs',
    'GetDeviceCollectionAccountCertificateDataStreetAddressArgsDict',
    'GetDeviceCollectionAccountCertificateInfoArgs',
    'GetDeviceCollectionAccountCertificateInfoArgsDict',
    'GetDeviceCollectionAccountKeyInfoArgs',
    'GetDeviceCollectionAccountKeyInfoArgsDict',
    'GetDeviceCollectionAccountReloadInfoArgs',
    'GetDeviceCollectionAccountReloadInfoArgsDict',
]

MYPY = False

if not MYPY:
    class AccountBrowserArgsDict(TypedDict):
        pass
elif False:
    AccountBrowserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountBrowserArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccountEthernetArgsDict(TypedDict):
        autojoin: NotRequired[pulumi.Input[bool]]
        ca_chain: NotRequired[pulumi.Input[str]]
        external_radius_server: NotRequired[pulumi.Input[bool]]
        network_access_server_ip: NotRequired[pulumi.Input[str]]
elif False:
    AccountEthernetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountEthernetArgs:
    def __init__(__self__, *,
                 autojoin: Optional[pulumi.Input[bool]] = None,
                 ca_chain: Optional[pulumi.Input[str]] = None,
                 external_radius_server: Optional[pulumi.Input[bool]] = None,
                 network_access_server_ip: Optional[pulumi.Input[str]] = None):
        if autojoin is not None:
            pulumi.set(__self__, "autojoin", autojoin)
        if ca_chain is not None:
            pulumi.set(__self__, "ca_chain", ca_chain)
        if external_radius_server is not None:
            pulumi.set(__self__, "external_radius_server", external_radius_server)
        if network_access_server_ip is not None:
            pulumi.set(__self__, "network_access_server_ip", network_access_server_ip)

    @property
    @pulumi.getter
    def autojoin(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "autojoin")

    @autojoin.setter
    def autojoin(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autojoin", value)

    @property
    @pulumi.getter(name="caChain")
    def ca_chain(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ca_chain")

    @ca_chain.setter
    def ca_chain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_chain", value)

    @property
    @pulumi.getter(name="externalRadiusServer")
    def external_radius_server(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "external_radius_server")

    @external_radius_server.setter
    def external_radius_server(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "external_radius_server", value)

    @property
    @pulumi.getter(name="networkAccessServerIp")
    def network_access_server_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "network_access_server_ip")

    @network_access_server_ip.setter
    def network_access_server_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_access_server_ip", value)


if not MYPY:
    class AccountVpnArgsDict(TypedDict):
        connection_type: pulumi.Input[str]
        """
        Allowed values: `IPSec` `IKEv2` `SSL`
        """
        remote_address: pulumi.Input[str]
        autojoin: NotRequired[pulumi.Input[bool]]
        ike: NotRequired[pulumi.Input['AccountVpnIkeArgsDict']]
        vendor: NotRequired[pulumi.Input[str]]
        """
        Allowed values: `F5` `Cisco` `Juniper`
        """
elif False:
    AccountVpnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountVpnArgs:
    def __init__(__self__, *,
                 connection_type: pulumi.Input[str],
                 remote_address: pulumi.Input[str],
                 autojoin: Optional[pulumi.Input[bool]] = None,
                 ike: Optional[pulumi.Input['AccountVpnIkeArgs']] = None,
                 vendor: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] connection_type: Allowed values: `IPSec` `IKEv2` `SSL`
        :param pulumi.Input[str] vendor: Allowed values: `F5` `Cisco` `Juniper`
        """
        pulumi.set(__self__, "connection_type", connection_type)
        pulumi.set(__self__, "remote_address", remote_address)
        if autojoin is not None:
            pulumi.set(__self__, "autojoin", autojoin)
        if ike is not None:
            pulumi.set(__self__, "ike", ike)
        if vendor is not None:
            pulumi.set(__self__, "vendor", vendor)

    @property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> pulumi.Input[str]:
        """
        Allowed values: `IPSec` `IKEv2` `SSL`
        """
        return pulumi.get(self, "connection_type")

    @connection_type.setter
    def connection_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "connection_type", value)

    @property
    @pulumi.getter(name="remoteAddress")
    def remote_address(self) -> pulumi.Input[str]:
        return pulumi.get(self, "remote_address")

    @remote_address.setter
    def remote_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "remote_address", value)

    @property
    @pulumi.getter
    def autojoin(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "autojoin")

    @autojoin.setter
    def autojoin(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autojoin", value)

    @property
    @pulumi.getter
    def ike(self) -> Optional[pulumi.Input['AccountVpnIkeArgs']]:
        return pulumi.get(self, "ike")

    @ike.setter
    def ike(self, value: Optional[pulumi.Input['AccountVpnIkeArgs']]):
        pulumi.set(self, "ike", value)

    @property
    @pulumi.getter
    def vendor(self) -> Optional[pulumi.Input[str]]:
        """
        Allowed values: `F5` `Cisco` `Juniper`
        """
        return pulumi.get(self, "vendor")

    @vendor.setter
    def vendor(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vendor", value)


if not MYPY:
    class AccountVpnIkeArgsDict(TypedDict):
        ca_chain: NotRequired[pulumi.Input[str]]
        eap: NotRequired[pulumi.Input[bool]]
        remote_id: NotRequired[pulumi.Input[str]]
        """
        Typically, the common name of the remote server. Defaults to the remote address.
        """
elif False:
    AccountVpnIkeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountVpnIkeArgs:
    def __init__(__self__, *,
                 ca_chain: Optional[pulumi.Input[str]] = None,
                 eap: Optional[pulumi.Input[bool]] = None,
                 remote_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] remote_id: Typically, the common name of the remote server. Defaults to the remote address.
        """
        if ca_chain is not None:
            pulumi.set(__self__, "ca_chain", ca_chain)
        if eap is not None:
            pulumi.set(__self__, "eap", eap)
        if remote_id is not None:
            pulumi.set(__self__, "remote_id", remote_id)

    @property
    @pulumi.getter(name="caChain")
    def ca_chain(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ca_chain")

    @ca_chain.setter
    def ca_chain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_chain", value)

    @property
    @pulumi.getter
    def eap(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "eap")

    @eap.setter
    def eap(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "eap", value)

    @property
    @pulumi.getter(name="remoteId")
    def remote_id(self) -> Optional[pulumi.Input[str]]:
        """
        Typically, the common name of the remote server. Defaults to the remote address.
        """
        return pulumi.get(self, "remote_id")

    @remote_id.setter
    def remote_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_id", value)


if not MYPY:
    class AccountWifiArgsDict(TypedDict):
        ssid: pulumi.Input[str]
        autojoin: NotRequired[pulumi.Input[bool]]
        ca_chain: NotRequired[pulumi.Input[str]]
        external_radius_server: NotRequired[pulumi.Input[bool]]
        hidden: NotRequired[pulumi.Input[bool]]
        network_access_server_ip: NotRequired[pulumi.Input[str]]
elif False:
    AccountWifiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountWifiArgs:
    def __init__(__self__, *,
                 ssid: pulumi.Input[str],
                 autojoin: Optional[pulumi.Input[bool]] = None,
                 ca_chain: Optional[pulumi.Input[str]] = None,
                 external_radius_server: Optional[pulumi.Input[bool]] = None,
                 hidden: Optional[pulumi.Input[bool]] = None,
                 network_access_server_ip: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "ssid", ssid)
        if autojoin is not None:
            pulumi.set(__self__, "autojoin", autojoin)
        if ca_chain is not None:
            pulumi.set(__self__, "ca_chain", ca_chain)
        if external_radius_server is not None:
            pulumi.set(__self__, "external_radius_server", external_radius_server)
        if hidden is not None:
            pulumi.set(__self__, "hidden", hidden)
        if network_access_server_ip is not None:
            pulumi.set(__self__, "network_access_server_ip", network_access_server_ip)

    @property
    @pulumi.getter
    def ssid(self) -> pulumi.Input[str]:
        return pulumi.get(self, "ssid")

    @ssid.setter
    def ssid(self, value: pulumi.Input[str]):
        pulumi.set(self, "ssid", value)

    @property
    @pulumi.getter
    def autojoin(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "autojoin")

    @autojoin.setter
    def autojoin(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autojoin", value)

    @property
    @pulumi.getter(name="caChain")
    def ca_chain(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ca_chain")

    @ca_chain.setter
    def ca_chain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_chain", value)

    @property
    @pulumi.getter(name="externalRadiusServer")
    def external_radius_server(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "external_radius_server")

    @external_radius_server.setter
    def external_radius_server(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "external_radius_server", value)

    @property
    @pulumi.getter
    def hidden(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "hidden")

    @hidden.setter
    def hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hidden", value)

    @property
    @pulumi.getter(name="networkAccessServerIp")
    def network_access_server_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "network_access_server_ip")

    @network_access_server_ip.setter
    def network_access_server_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_access_server_ip", value)


if not MYPY:
    class AuthorityIntermediateIssuerArgsDict(TypedDict):
        key_version: pulumi.Input[str]
        """
        The signature algorithm.
         Allowed values: `EC_SIGN_P256_SHA256` `EC_SIGN_P384_SHA384` `RSA_SIGN_PKCS1_2048_SHA256` `RSA_SIGN_PKCS1_3072_SHA256` `RSA_SIGN_PKCS1_4096_SHA256` `RSA_SIGN_PKCS1_4096_SHA512` `RSA_SIGN_PSS_2048_SHA256` `RSA_SIGN_PSS_3072_SHA256` `RSA_SIGN_PSS_4096_SHA256` `RSA_SIGN_PSS_4096_SHA512`
        """
        name: pulumi.Input[str]
        """
        The name of the issuer.
        """
        duration: NotRequired[pulumi.Input[str]]
        """
        The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        max_path_length: NotRequired[pulumi.Input[float]]
        name_constraints: NotRequired[pulumi.Input['AuthorityIntermediateIssuerNameConstraintsArgsDict']]
        """
        X509 certificate name constraints.
        """
        subject: NotRequired[pulumi.Input['AuthorityIntermediateIssuerSubjectArgsDict']]
        """
        Name used in x509 certificates
        """
elif False:
    AuthorityIntermediateIssuerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorityIntermediateIssuerArgs:
    def __init__(__self__, *,
                 key_version: pulumi.Input[str],
                 name: pulumi.Input[str],
                 duration: Optional[pulumi.Input[str]] = None,
                 max_path_length: Optional[pulumi.Input[float]] = None,
                 name_constraints: Optional[pulumi.Input['AuthorityIntermediateIssuerNameConstraintsArgs']] = None,
                 subject: Optional[pulumi.Input['AuthorityIntermediateIssuerSubjectArgs']] = None):
        """
        :param pulumi.Input[str] key_version: The signature algorithm.
                Allowed values: `EC_SIGN_P256_SHA256` `EC_SIGN_P384_SHA384` `RSA_SIGN_PKCS1_2048_SHA256` `RSA_SIGN_PKCS1_3072_SHA256` `RSA_SIGN_PKCS1_4096_SHA256` `RSA_SIGN_PKCS1_4096_SHA512` `RSA_SIGN_PSS_2048_SHA256` `RSA_SIGN_PSS_3072_SHA256` `RSA_SIGN_PSS_4096_SHA256` `RSA_SIGN_PSS_4096_SHA512`
        :param pulumi.Input[str] name: The name of the issuer.
        :param pulumi.Input[str] duration: The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param pulumi.Input['AuthorityIntermediateIssuerNameConstraintsArgs'] name_constraints: X509 certificate name constraints.
        :param pulumi.Input['AuthorityIntermediateIssuerSubjectArgs'] subject: Name used in x509 certificates
        """
        pulumi.set(__self__, "key_version", key_version)
        pulumi.set(__self__, "name", name)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if max_path_length is not None:
            pulumi.set(__self__, "max_path_length", max_path_length)
        if name_constraints is not None:
            pulumi.set(__self__, "name_constraints", name_constraints)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter(name="keyVersion")
    def key_version(self) -> pulumi.Input[str]:
        """
        The signature algorithm.
         Allowed values: `EC_SIGN_P256_SHA256` `EC_SIGN_P384_SHA384` `RSA_SIGN_PKCS1_2048_SHA256` `RSA_SIGN_PKCS1_3072_SHA256` `RSA_SIGN_PKCS1_4096_SHA256` `RSA_SIGN_PKCS1_4096_SHA512` `RSA_SIGN_PSS_2048_SHA256` `RSA_SIGN_PSS_3072_SHA256` `RSA_SIGN_PSS_4096_SHA256` `RSA_SIGN_PSS_4096_SHA512`
        """
        return pulumi.get(self, "key_version")

    @key_version.setter
    def key_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_version", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the issuer.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[str]]:
        """
        The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="maxPathLength")
    def max_path_length(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "max_path_length")

    @max_path_length.setter
    def max_path_length(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_path_length", value)

    @property
    @pulumi.getter(name="nameConstraints")
    def name_constraints(self) -> Optional[pulumi.Input['AuthorityIntermediateIssuerNameConstraintsArgs']]:
        """
        X509 certificate name constraints.
        """
        return pulumi.get(self, "name_constraints")

    @name_constraints.setter
    def name_constraints(self, value: Optional[pulumi.Input['AuthorityIntermediateIssuerNameConstraintsArgs']]):
        pulumi.set(self, "name_constraints", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input['AuthorityIntermediateIssuerSubjectArgs']]:
        """
        Name used in x509 certificates
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input['AuthorityIntermediateIssuerSubjectArgs']]):
        pulumi.set(self, "subject", value)


if not MYPY:
    class AuthorityIntermediateIssuerNameConstraintsArgsDict(TypedDict):
        critical: NotRequired[pulumi.Input[bool]]
        """
        Whether or not name constraints are marked critical.
        """
        excluded_dns_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        excluded_email_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        excluded_ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        excluded_uri_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        permitted_dns_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        permitted_email_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        permitted_ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        permitted_uri_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    AuthorityIntermediateIssuerNameConstraintsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorityIntermediateIssuerNameConstraintsArgs:
    def __init__(__self__, *,
                 critical: Optional[pulumi.Input[bool]] = None,
                 excluded_dns_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 excluded_email_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 excluded_ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 excluded_uri_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 permitted_dns_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 permitted_email_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 permitted_ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 permitted_uri_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] critical: Whether or not name constraints are marked critical.
        """
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if excluded_dns_domains is not None:
            pulumi.set(__self__, "excluded_dns_domains", excluded_dns_domains)
        if excluded_email_addresses is not None:
            pulumi.set(__self__, "excluded_email_addresses", excluded_email_addresses)
        if excluded_ip_ranges is not None:
            pulumi.set(__self__, "excluded_ip_ranges", excluded_ip_ranges)
        if excluded_uri_domains is not None:
            pulumi.set(__self__, "excluded_uri_domains", excluded_uri_domains)
        if permitted_dns_domains is not None:
            pulumi.set(__self__, "permitted_dns_domains", permitted_dns_domains)
        if permitted_email_addresses is not None:
            pulumi.set(__self__, "permitted_email_addresses", permitted_email_addresses)
        if permitted_ip_ranges is not None:
            pulumi.set(__self__, "permitted_ip_ranges", permitted_ip_ranges)
        if permitted_uri_domains is not None:
            pulumi.set(__self__, "permitted_uri_domains", permitted_uri_domains)

    @property
    @pulumi.getter
    def critical(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not name constraints are marked critical.
        """
        return pulumi.get(self, "critical")

    @critical.setter
    def critical(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "critical", value)

    @property
    @pulumi.getter(name="excludedDnsDomains")
    def excluded_dns_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_dns_domains")

    @excluded_dns_domains.setter
    def excluded_dns_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_dns_domains", value)

    @property
    @pulumi.getter(name="excludedEmailAddresses")
    def excluded_email_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_email_addresses")

    @excluded_email_addresses.setter
    def excluded_email_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_email_addresses", value)

    @property
    @pulumi.getter(name="excludedIpRanges")
    def excluded_ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_ip_ranges")

    @excluded_ip_ranges.setter
    def excluded_ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_ip_ranges", value)

    @property
    @pulumi.getter(name="excludedUriDomains")
    def excluded_uri_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_uri_domains")

    @excluded_uri_domains.setter
    def excluded_uri_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_uri_domains", value)

    @property
    @pulumi.getter(name="permittedDnsDomains")
    def permitted_dns_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "permitted_dns_domains")

    @permitted_dns_domains.setter
    def permitted_dns_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "permitted_dns_domains", value)

    @property
    @pulumi.getter(name="permittedEmailAddresses")
    def permitted_email_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "permitted_email_addresses")

    @permitted_email_addresses.setter
    def permitted_email_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "permitted_email_addresses", value)

    @property
    @pulumi.getter(name="permittedIpRanges")
    def permitted_ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "permitted_ip_ranges")

    @permitted_ip_ranges.setter
    def permitted_ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "permitted_ip_ranges", value)

    @property
    @pulumi.getter(name="permittedUriDomains")
    def permitted_uri_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "permitted_uri_domains")

    @permitted_uri_domains.setter
    def permitted_uri_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "permitted_uri_domains", value)


if not MYPY:
    class AuthorityIntermediateIssuerSubjectArgsDict(TypedDict):
        common_name: NotRequired[pulumi.Input[str]]
        country: NotRequired[pulumi.Input[str]]
        email_address: NotRequired[pulumi.Input[str]]
        locality: NotRequired[pulumi.Input[str]]
        organization: NotRequired[pulumi.Input[str]]
        organizational_unit: NotRequired[pulumi.Input[str]]
        postal_code: NotRequired[pulumi.Input[str]]
        province: NotRequired[pulumi.Input[str]]
        serial_number: NotRequired[pulumi.Input[str]]
        street_address: NotRequired[pulumi.Input[str]]
elif False:
    AuthorityIntermediateIssuerSubjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorityIntermediateIssuerSubjectArgs:
    def __init__(__self__, *,
                 common_name: Optional[pulumi.Input[str]] = None,
                 country: Optional[pulumi.Input[str]] = None,
                 email_address: Optional[pulumi.Input[str]] = None,
                 locality: Optional[pulumi.Input[str]] = None,
                 organization: Optional[pulumi.Input[str]] = None,
                 organizational_unit: Optional[pulumi.Input[str]] = None,
                 postal_code: Optional[pulumi.Input[str]] = None,
                 province: Optional[pulumi.Input[str]] = None,
                 serial_number: Optional[pulumi.Input[str]] = None,
                 street_address: Optional[pulumi.Input[str]] = None):
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if email_address is not None:
            pulumi.set(__self__, "email_address", email_address)
        if locality is not None:
            pulumi.set(__self__, "locality", locality)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if organizational_unit is not None:
            pulumi.set(__self__, "organizational_unit", organizational_unit)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if province is not None:
            pulumi.set(__self__, "province", province)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)
        if street_address is not None:
            pulumi.set(__self__, "street_address", street_address)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter
    def country(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "country", value)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "email_address")

    @email_address.setter
    def email_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_address", value)

    @property
    @pulumi.getter
    def locality(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "locality")

    @locality.setter
    def locality(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locality", value)

    @property
    @pulumi.getter
    def organization(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "organization", value)

    @property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "organizational_unit")

    @organizational_unit.setter
    def organizational_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "organizational_unit", value)

    @property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "postal_code")

    @postal_code.setter
    def postal_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "postal_code", value)

    @property
    @pulumi.getter
    def province(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "province")

    @province.setter
    def province(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "province", value)

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "serial_number")

    @serial_number.setter
    def serial_number(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "serial_number", value)

    @property
    @pulumi.getter(name="streetAddress")
    def street_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "street_address")

    @street_address.setter
    def street_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "street_address", value)


if not MYPY:
    class AuthorityRootIssuerArgsDict(TypedDict):
        key_version: pulumi.Input[str]
        """
        The signature algorithm.
         Allowed values: `EC_SIGN_P256_SHA256` `EC_SIGN_P384_SHA384` `RSA_SIGN_PKCS1_2048_SHA256` `RSA_SIGN_PKCS1_3072_SHA256` `RSA_SIGN_PKCS1_4096_SHA256` `RSA_SIGN_PKCS1_4096_SHA512` `RSA_SIGN_PSS_2048_SHA256` `RSA_SIGN_PSS_3072_SHA256` `RSA_SIGN_PSS_4096_SHA256` `RSA_SIGN_PSS_4096_SHA512`
        """
        name: pulumi.Input[str]
        """
        The name of the issuer.
        """
        duration: NotRequired[pulumi.Input[str]]
        """
        The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        max_path_length: NotRequired[pulumi.Input[float]]
        name_constraints: NotRequired[pulumi.Input['AuthorityRootIssuerNameConstraintsArgsDict']]
        """
        X509 certificate name constraints.
        """
        subject: NotRequired[pulumi.Input['AuthorityRootIssuerSubjectArgsDict']]
        """
        Name used in x509 certificates
        """
elif False:
    AuthorityRootIssuerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorityRootIssuerArgs:
    def __init__(__self__, *,
                 key_version: pulumi.Input[str],
                 name: pulumi.Input[str],
                 duration: Optional[pulumi.Input[str]] = None,
                 max_path_length: Optional[pulumi.Input[float]] = None,
                 name_constraints: Optional[pulumi.Input['AuthorityRootIssuerNameConstraintsArgs']] = None,
                 subject: Optional[pulumi.Input['AuthorityRootIssuerSubjectArgs']] = None):
        """
        :param pulumi.Input[str] key_version: The signature algorithm.
                Allowed values: `EC_SIGN_P256_SHA256` `EC_SIGN_P384_SHA384` `RSA_SIGN_PKCS1_2048_SHA256` `RSA_SIGN_PKCS1_3072_SHA256` `RSA_SIGN_PKCS1_4096_SHA256` `RSA_SIGN_PKCS1_4096_SHA512` `RSA_SIGN_PSS_2048_SHA256` `RSA_SIGN_PSS_3072_SHA256` `RSA_SIGN_PSS_4096_SHA256` `RSA_SIGN_PSS_4096_SHA512`
        :param pulumi.Input[str] name: The name of the issuer.
        :param pulumi.Input[str] duration: The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param pulumi.Input['AuthorityRootIssuerNameConstraintsArgs'] name_constraints: X509 certificate name constraints.
        :param pulumi.Input['AuthorityRootIssuerSubjectArgs'] subject: Name used in x509 certificates
        """
        pulumi.set(__self__, "key_version", key_version)
        pulumi.set(__self__, "name", name)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if max_path_length is not None:
            pulumi.set(__self__, "max_path_length", max_path_length)
        if name_constraints is not None:
            pulumi.set(__self__, "name_constraints", name_constraints)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter(name="keyVersion")
    def key_version(self) -> pulumi.Input[str]:
        """
        The signature algorithm.
         Allowed values: `EC_SIGN_P256_SHA256` `EC_SIGN_P384_SHA384` `RSA_SIGN_PKCS1_2048_SHA256` `RSA_SIGN_PKCS1_3072_SHA256` `RSA_SIGN_PKCS1_4096_SHA256` `RSA_SIGN_PKCS1_4096_SHA512` `RSA_SIGN_PSS_2048_SHA256` `RSA_SIGN_PSS_3072_SHA256` `RSA_SIGN_PSS_4096_SHA256` `RSA_SIGN_PSS_4096_SHA512`
        """
        return pulumi.get(self, "key_version")

    @key_version.setter
    def key_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_version", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the issuer.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[str]]:
        """
        The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="maxPathLength")
    def max_path_length(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "max_path_length")

    @max_path_length.setter
    def max_path_length(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_path_length", value)

    @property
    @pulumi.getter(name="nameConstraints")
    def name_constraints(self) -> Optional[pulumi.Input['AuthorityRootIssuerNameConstraintsArgs']]:
        """
        X509 certificate name constraints.
        """
        return pulumi.get(self, "name_constraints")

    @name_constraints.setter
    def name_constraints(self, value: Optional[pulumi.Input['AuthorityRootIssuerNameConstraintsArgs']]):
        pulumi.set(self, "name_constraints", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input['AuthorityRootIssuerSubjectArgs']]:
        """
        Name used in x509 certificates
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input['AuthorityRootIssuerSubjectArgs']]):
        pulumi.set(self, "subject", value)


if not MYPY:
    class AuthorityRootIssuerNameConstraintsArgsDict(TypedDict):
        critical: NotRequired[pulumi.Input[bool]]
        """
        Whether or not name constraints are marked critical.
        """
        excluded_dns_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        excluded_email_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        excluded_ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        excluded_uri_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        permitted_dns_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        permitted_email_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        permitted_ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        permitted_uri_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    AuthorityRootIssuerNameConstraintsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorityRootIssuerNameConstraintsArgs:
    def __init__(__self__, *,
                 critical: Optional[pulumi.Input[bool]] = None,
                 excluded_dns_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 excluded_email_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 excluded_ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 excluded_uri_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 permitted_dns_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 permitted_email_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 permitted_ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 permitted_uri_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] critical: Whether or not name constraints are marked critical.
        """
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if excluded_dns_domains is not None:
            pulumi.set(__self__, "excluded_dns_domains", excluded_dns_domains)
        if excluded_email_addresses is not None:
            pulumi.set(__self__, "excluded_email_addresses", excluded_email_addresses)
        if excluded_ip_ranges is not None:
            pulumi.set(__self__, "excluded_ip_ranges", excluded_ip_ranges)
        if excluded_uri_domains is not None:
            pulumi.set(__self__, "excluded_uri_domains", excluded_uri_domains)
        if permitted_dns_domains is not None:
            pulumi.set(__self__, "permitted_dns_domains", permitted_dns_domains)
        if permitted_email_addresses is not None:
            pulumi.set(__self__, "permitted_email_addresses", permitted_email_addresses)
        if permitted_ip_ranges is not None:
            pulumi.set(__self__, "permitted_ip_ranges", permitted_ip_ranges)
        if permitted_uri_domains is not None:
            pulumi.set(__self__, "permitted_uri_domains", permitted_uri_domains)

    @property
    @pulumi.getter
    def critical(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not name constraints are marked critical.
        """
        return pulumi.get(self, "critical")

    @critical.setter
    def critical(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "critical", value)

    @property
    @pulumi.getter(name="excludedDnsDomains")
    def excluded_dns_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_dns_domains")

    @excluded_dns_domains.setter
    def excluded_dns_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_dns_domains", value)

    @property
    @pulumi.getter(name="excludedEmailAddresses")
    def excluded_email_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_email_addresses")

    @excluded_email_addresses.setter
    def excluded_email_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_email_addresses", value)

    @property
    @pulumi.getter(name="excludedIpRanges")
    def excluded_ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_ip_ranges")

    @excluded_ip_ranges.setter
    def excluded_ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_ip_ranges", value)

    @property
    @pulumi.getter(name="excludedUriDomains")
    def excluded_uri_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_uri_domains")

    @excluded_uri_domains.setter
    def excluded_uri_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_uri_domains", value)

    @property
    @pulumi.getter(name="permittedDnsDomains")
    def permitted_dns_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "permitted_dns_domains")

    @permitted_dns_domains.setter
    def permitted_dns_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "permitted_dns_domains", value)

    @property
    @pulumi.getter(name="permittedEmailAddresses")
    def permitted_email_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "permitted_email_addresses")

    @permitted_email_addresses.setter
    def permitted_email_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "permitted_email_addresses", value)

    @property
    @pulumi.getter(name="permittedIpRanges")
    def permitted_ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "permitted_ip_ranges")

    @permitted_ip_ranges.setter
    def permitted_ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "permitted_ip_ranges", value)

    @property
    @pulumi.getter(name="permittedUriDomains")
    def permitted_uri_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "permitted_uri_domains")

    @permitted_uri_domains.setter
    def permitted_uri_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "permitted_uri_domains", value)


if not MYPY:
    class AuthorityRootIssuerSubjectArgsDict(TypedDict):
        common_name: NotRequired[pulumi.Input[str]]
        country: NotRequired[pulumi.Input[str]]
        email_address: NotRequired[pulumi.Input[str]]
        locality: NotRequired[pulumi.Input[str]]
        organization: NotRequired[pulumi.Input[str]]
        organizational_unit: NotRequired[pulumi.Input[str]]
        postal_code: NotRequired[pulumi.Input[str]]
        province: NotRequired[pulumi.Input[str]]
        serial_number: NotRequired[pulumi.Input[str]]
        street_address: NotRequired[pulumi.Input[str]]
elif False:
    AuthorityRootIssuerSubjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorityRootIssuerSubjectArgs:
    def __init__(__self__, *,
                 common_name: Optional[pulumi.Input[str]] = None,
                 country: Optional[pulumi.Input[str]] = None,
                 email_address: Optional[pulumi.Input[str]] = None,
                 locality: Optional[pulumi.Input[str]] = None,
                 organization: Optional[pulumi.Input[str]] = None,
                 organizational_unit: Optional[pulumi.Input[str]] = None,
                 postal_code: Optional[pulumi.Input[str]] = None,
                 province: Optional[pulumi.Input[str]] = None,
                 serial_number: Optional[pulumi.Input[str]] = None,
                 street_address: Optional[pulumi.Input[str]] = None):
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if email_address is not None:
            pulumi.set(__self__, "email_address", email_address)
        if locality is not None:
            pulumi.set(__self__, "locality", locality)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if organizational_unit is not None:
            pulumi.set(__self__, "organizational_unit", organizational_unit)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if province is not None:
            pulumi.set(__self__, "province", province)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)
        if street_address is not None:
            pulumi.set(__self__, "street_address", street_address)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter
    def country(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "country", value)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "email_address")

    @email_address.setter
    def email_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_address", value)

    @property
    @pulumi.getter
    def locality(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "locality")

    @locality.setter
    def locality(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locality", value)

    @property
    @pulumi.getter
    def organization(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "organization", value)

    @property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "organizational_unit")

    @organizational_unit.setter
    def organizational_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "organizational_unit", value)

    @property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "postal_code")

    @postal_code.setter
    def postal_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "postal_code", value)

    @property
    @pulumi.getter
    def province(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "province")

    @province.setter
    def province(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "province", value)

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "serial_number")

    @serial_number.setter
    def serial_number(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "serial_number", value)

    @property
    @pulumi.getter(name="streetAddress")
    def street_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "street_address")

    @street_address.setter
    def street_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "street_address", value)


if not MYPY:
    class DeviceCollectionAccountCertificateDataArgsDict(TypedDict):
        common_name: pulumi.Input['DeviceCollectionAccountCertificateDataCommonNameArgsDict']
        country: NotRequired[pulumi.Input['DeviceCollectionAccountCertificateDataCountryArgsDict']]
        locality: NotRequired[pulumi.Input['DeviceCollectionAccountCertificateDataLocalityArgsDict']]
        organization: NotRequired[pulumi.Input['DeviceCollectionAccountCertificateDataOrganizationArgsDict']]
        organizational_unit: NotRequired[pulumi.Input['DeviceCollectionAccountCertificateDataOrganizationalUnitArgsDict']]
        postal_code: NotRequired[pulumi.Input['DeviceCollectionAccountCertificateDataPostalCodeArgsDict']]
        province: NotRequired[pulumi.Input['DeviceCollectionAccountCertificateDataProvinceArgsDict']]
        sans: NotRequired[pulumi.Input['DeviceCollectionAccountCertificateDataSansArgsDict']]
        street_address: NotRequired[pulumi.Input['DeviceCollectionAccountCertificateDataStreetAddressArgsDict']]
elif False:
    DeviceCollectionAccountCertificateDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceCollectionAccountCertificateDataArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input['DeviceCollectionAccountCertificateDataCommonNameArgs'],
                 country: Optional[pulumi.Input['DeviceCollectionAccountCertificateDataCountryArgs']] = None,
                 locality: Optional[pulumi.Input['DeviceCollectionAccountCertificateDataLocalityArgs']] = None,
                 organization: Optional[pulumi.Input['DeviceCollectionAccountCertificateDataOrganizationArgs']] = None,
                 organizational_unit: Optional[pulumi.Input['DeviceCollectionAccountCertificateDataOrganizationalUnitArgs']] = None,
                 postal_code: Optional[pulumi.Input['DeviceCollectionAccountCertificateDataPostalCodeArgs']] = None,
                 province: Optional[pulumi.Input['DeviceCollectionAccountCertificateDataProvinceArgs']] = None,
                 sans: Optional[pulumi.Input['DeviceCollectionAccountCertificateDataSansArgs']] = None,
                 street_address: Optional[pulumi.Input['DeviceCollectionAccountCertificateDataStreetAddressArgs']] = None):
        pulumi.set(__self__, "common_name", common_name)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if locality is not None:
            pulumi.set(__self__, "locality", locality)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if organizational_unit is not None:
            pulumi.set(__self__, "organizational_unit", organizational_unit)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if province is not None:
            pulumi.set(__self__, "province", province)
        if sans is not None:
            pulumi.set(__self__, "sans", sans)
        if street_address is not None:
            pulumi.set(__self__, "street_address", street_address)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input['DeviceCollectionAccountCertificateDataCommonNameArgs']:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input['DeviceCollectionAccountCertificateDataCommonNameArgs']):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter
    def country(self) -> Optional[pulumi.Input['DeviceCollectionAccountCertificateDataCountryArgs']]:
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: Optional[pulumi.Input['DeviceCollectionAccountCertificateDataCountryArgs']]):
        pulumi.set(self, "country", value)

    @property
    @pulumi.getter
    def locality(self) -> Optional[pulumi.Input['DeviceCollectionAccountCertificateDataLocalityArgs']]:
        return pulumi.get(self, "locality")

    @locality.setter
    def locality(self, value: Optional[pulumi.Input['DeviceCollectionAccountCertificateDataLocalityArgs']]):
        pulumi.set(self, "locality", value)

    @property
    @pulumi.getter
    def organization(self) -> Optional[pulumi.Input['DeviceCollectionAccountCertificateDataOrganizationArgs']]:
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: Optional[pulumi.Input['DeviceCollectionAccountCertificateDataOrganizationArgs']]):
        pulumi.set(self, "organization", value)

    @property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> Optional[pulumi.Input['DeviceCollectionAccountCertificateDataOrganizationalUnitArgs']]:
        return pulumi.get(self, "organizational_unit")

    @organizational_unit.setter
    def organizational_unit(self, value: Optional[pulumi.Input['DeviceCollectionAccountCertificateDataOrganizationalUnitArgs']]):
        pulumi.set(self, "organizational_unit", value)

    @property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional[pulumi.Input['DeviceCollectionAccountCertificateDataPostalCodeArgs']]:
        return pulumi.get(self, "postal_code")

    @postal_code.setter
    def postal_code(self, value: Optional[pulumi.Input['DeviceCollectionAccountCertificateDataPostalCodeArgs']]):
        pulumi.set(self, "postal_code", value)

    @property
    @pulumi.getter
    def province(self) -> Optional[pulumi.Input['DeviceCollectionAccountCertificateDataProvinceArgs']]:
        return pulumi.get(self, "province")

    @province.setter
    def province(self, value: Optional[pulumi.Input['DeviceCollectionAccountCertificateDataProvinceArgs']]):
        pulumi.set(self, "province", value)

    @property
    @pulumi.getter
    def sans(self) -> Optional[pulumi.Input['DeviceCollectionAccountCertificateDataSansArgs']]:
        return pulumi.get(self, "sans")

    @sans.setter
    def sans(self, value: Optional[pulumi.Input['DeviceCollectionAccountCertificateDataSansArgs']]):
        pulumi.set(self, "sans", value)

    @property
    @pulumi.getter(name="streetAddress")
    def street_address(self) -> Optional[pulumi.Input['DeviceCollectionAccountCertificateDataStreetAddressArgs']]:
        return pulumi.get(self, "street_address")

    @street_address.setter
    def street_address(self, value: Optional[pulumi.Input['DeviceCollectionAccountCertificateDataStreetAddressArgs']]):
        pulumi.set(self, "street_address", value)


if not MYPY:
    class DeviceCollectionAccountCertificateDataCommonNameArgsDict(TypedDict):
        device_metadata: NotRequired[pulumi.Input[str]]
        static: NotRequired[pulumi.Input[str]]
elif False:
    DeviceCollectionAccountCertificateDataCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceCollectionAccountCertificateDataCommonNameArgs:
    def __init__(__self__, *,
                 device_metadata: Optional[pulumi.Input[str]] = None,
                 static: Optional[pulumi.Input[str]] = None):
        if device_metadata is not None:
            pulumi.set(__self__, "device_metadata", device_metadata)
        if static is not None:
            pulumi.set(__self__, "static", static)

    @property
    @pulumi.getter(name="deviceMetadata")
    def device_metadata(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "device_metadata")

    @device_metadata.setter
    def device_metadata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_metadata", value)

    @property
    @pulumi.getter
    def static(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "static")

    @static.setter
    def static(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "static", value)


if not MYPY:
    class DeviceCollectionAccountCertificateDataCountryArgsDict(TypedDict):
        device_metadatas: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        statics: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    DeviceCollectionAccountCertificateDataCountryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceCollectionAccountCertificateDataCountryArgs:
    def __init__(__self__, *,
                 device_metadatas: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 statics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "device_metadatas")

    @device_metadatas.setter
    def device_metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_metadatas", value)

    @property
    @pulumi.getter
    def statics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "statics")

    @statics.setter
    def statics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "statics", value)


if not MYPY:
    class DeviceCollectionAccountCertificateDataLocalityArgsDict(TypedDict):
        device_metadatas: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        statics: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    DeviceCollectionAccountCertificateDataLocalityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceCollectionAccountCertificateDataLocalityArgs:
    def __init__(__self__, *,
                 device_metadatas: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 statics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "device_metadatas")

    @device_metadatas.setter
    def device_metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_metadatas", value)

    @property
    @pulumi.getter
    def statics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "statics")

    @statics.setter
    def statics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "statics", value)


if not MYPY:
    class DeviceCollectionAccountCertificateDataOrganizationArgsDict(TypedDict):
        device_metadatas: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        statics: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    DeviceCollectionAccountCertificateDataOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceCollectionAccountCertificateDataOrganizationArgs:
    def __init__(__self__, *,
                 device_metadatas: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 statics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "device_metadatas")

    @device_metadatas.setter
    def device_metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_metadatas", value)

    @property
    @pulumi.getter
    def statics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "statics")

    @statics.setter
    def statics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "statics", value)


if not MYPY:
    class DeviceCollectionAccountCertificateDataOrganizationalUnitArgsDict(TypedDict):
        device_metadatas: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        statics: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    DeviceCollectionAccountCertificateDataOrganizationalUnitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceCollectionAccountCertificateDataOrganizationalUnitArgs:
    def __init__(__self__, *,
                 device_metadatas: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 statics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "device_metadatas")

    @device_metadatas.setter
    def device_metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_metadatas", value)

    @property
    @pulumi.getter
    def statics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "statics")

    @statics.setter
    def statics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "statics", value)


if not MYPY:
    class DeviceCollectionAccountCertificateDataPostalCodeArgsDict(TypedDict):
        device_metadatas: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        statics: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    DeviceCollectionAccountCertificateDataPostalCodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceCollectionAccountCertificateDataPostalCodeArgs:
    def __init__(__self__, *,
                 device_metadatas: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 statics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "device_metadatas")

    @device_metadatas.setter
    def device_metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_metadatas", value)

    @property
    @pulumi.getter
    def statics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "statics")

    @statics.setter
    def statics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "statics", value)


if not MYPY:
    class DeviceCollectionAccountCertificateDataProvinceArgsDict(TypedDict):
        device_metadatas: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        statics: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    DeviceCollectionAccountCertificateDataProvinceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceCollectionAccountCertificateDataProvinceArgs:
    def __init__(__self__, *,
                 device_metadatas: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 statics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "device_metadatas")

    @device_metadatas.setter
    def device_metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_metadatas", value)

    @property
    @pulumi.getter
    def statics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "statics")

    @statics.setter
    def statics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "statics", value)


if not MYPY:
    class DeviceCollectionAccountCertificateDataSansArgsDict(TypedDict):
        device_metadatas: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        statics: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    DeviceCollectionAccountCertificateDataSansArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceCollectionAccountCertificateDataSansArgs:
    def __init__(__self__, *,
                 device_metadatas: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 statics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "device_metadatas")

    @device_metadatas.setter
    def device_metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_metadatas", value)

    @property
    @pulumi.getter
    def statics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "statics")

    @statics.setter
    def statics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "statics", value)


if not MYPY:
    class DeviceCollectionAccountCertificateDataStreetAddressArgsDict(TypedDict):
        device_metadatas: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        statics: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    DeviceCollectionAccountCertificateDataStreetAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceCollectionAccountCertificateDataStreetAddressArgs:
    def __init__(__self__, *,
                 device_metadatas: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 statics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "device_metadatas")

    @device_metadatas.setter
    def device_metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_metadatas", value)

    @property
    @pulumi.getter
    def statics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "statics")

    @statics.setter
    def statics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "statics", value)


if not MYPY:
    class DeviceCollectionAccountCertificateInfoArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The type of certificate. Allowed values: `X509` `SSH_USER` `SSH_HOST`
        """
        crt_file: NotRequired[pulumi.Input[str]]
        """
        The filepath where the certificate is to be stored.
        """
        duration: NotRequired[pulumi.Input[str]]
        """
        The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        gid: NotRequired[pulumi.Input[float]]
        """
        GID of the files where the certificate is stored.
        """
        key_file: NotRequired[pulumi.Input[str]]
        """
        The filepath where the key is to be stored.
        """
        mode: NotRequired[pulumi.Input[float]]
        """
        Permission bits of the files where the certificate is stored.
        """
        root_file: NotRequired[pulumi.Input[str]]
        """
        The filepath where the root certificate is to be stored.
        """
        uid: NotRequired[pulumi.Input[float]]
        """
        UID of the files where the certificate is stored.
        """
elif False:
    DeviceCollectionAccountCertificateInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceCollectionAccountCertificateInfoArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 crt_file: Optional[pulumi.Input[str]] = None,
                 duration: Optional[pulumi.Input[str]] = None,
                 gid: Optional[pulumi.Input[float]] = None,
                 key_file: Optional[pulumi.Input[str]] = None,
                 mode: Optional[pulumi.Input[float]] = None,
                 root_file: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] type: The type of certificate. Allowed values: `X509` `SSH_USER` `SSH_HOST`
        :param pulumi.Input[str] crt_file: The filepath where the certificate is to be stored.
        :param pulumi.Input[str] duration: The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param pulumi.Input[float] gid: GID of the files where the certificate is stored.
        :param pulumi.Input[str] key_file: The filepath where the key is to be stored.
        :param pulumi.Input[float] mode: Permission bits of the files where the certificate is stored.
        :param pulumi.Input[str] root_file: The filepath where the root certificate is to be stored.
        :param pulumi.Input[float] uid: UID of the files where the certificate is stored.
        """
        pulumi.set(__self__, "type", type)
        if crt_file is not None:
            pulumi.set(__self__, "crt_file", crt_file)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if gid is not None:
            pulumi.set(__self__, "gid", gid)
        if key_file is not None:
            pulumi.set(__self__, "key_file", key_file)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if root_file is not None:
            pulumi.set(__self__, "root_file", root_file)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of certificate. Allowed values: `X509` `SSH_USER` `SSH_HOST`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="crtFile")
    def crt_file(self) -> Optional[pulumi.Input[str]]:
        """
        The filepath where the certificate is to be stored.
        """
        return pulumi.get(self, "crt_file")

    @crt_file.setter
    def crt_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "crt_file", value)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[str]]:
        """
        The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter
    def gid(self) -> Optional[pulumi.Input[float]]:
        """
        GID of the files where the certificate is stored.
        """
        return pulumi.get(self, "gid")

    @gid.setter
    def gid(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "gid", value)

    @property
    @pulumi.getter(name="keyFile")
    def key_file(self) -> Optional[pulumi.Input[str]]:
        """
        The filepath where the key is to be stored.
        """
        return pulumi.get(self, "key_file")

    @key_file.setter
    def key_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_file", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[float]]:
        """
        Permission bits of the files where the certificate is stored.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="rootFile")
    def root_file(self) -> Optional[pulumi.Input[str]]:
        """
        The filepath where the root certificate is to be stored.
        """
        return pulumi.get(self, "root_file")

    @root_file.setter
    def root_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "root_file", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[float]]:
        """
        UID of the files where the certificate is stored.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class DeviceCollectionAccountKeyInfoArgsDict(TypedDict):
        format: pulumi.Input[str]
        """
        The format used to encode the private key. For X509 keys the default format is PKCS#8. The classic format is PKCS#1 for RSA keys, SEC 1 for ECDSA keys, and PKCS#8 for ED25519 keys. For SSH keys the default format is always the OPENSSH format. When a hardware module is used to store the keys the default will be a JSON representation of the key, except on Linux where tss2 will be used. Allowed values: `DEFAULT` `PKCS8` `OPENSSH` `TSS2` `CLASSIC`
        """
        type: pulumi.Input[str]
        """
        The key type used. The current DEFAULT type is ECDSA_P256. Allowed values: `DEFAULT` `ECDSA_P256` `ECDSA_P384` `ECDSA_P521` `RSA_2048` `RSA_3072` `RSA_4096` `ED25519`
        """
        protection: NotRequired[pulumi.Input[str]]
        """
        Whether to use a hardware module to store the private key for a workload certificate. If set to `NONE` no hardware module will be used. If set to `DEFAULT` a hardware module will only be used with format `TSS2`. `HARDWARE_WITH_FALLBACK` can only be used with the key format `DEFAULT`. Allowed values: `DEFAULT` `NONE` `HARDWARE` `HARDWARE_WITH_FALLBACK` `HARDWARE_ATTESTED`
        """
        pub_file: NotRequired[pulumi.Input[str]]
        """
        A CSR or SSH public key to use instead of generating one.
        """
elif False:
    DeviceCollectionAccountKeyInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceCollectionAccountKeyInfoArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 type: pulumi.Input[str],
                 protection: Optional[pulumi.Input[str]] = None,
                 pub_file: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] format: The format used to encode the private key. For X509 keys the default format is PKCS#8. The classic format is PKCS#1 for RSA keys, SEC 1 for ECDSA keys, and PKCS#8 for ED25519 keys. For SSH keys the default format is always the OPENSSH format. When a hardware module is used to store the keys the default will be a JSON representation of the key, except on Linux where tss2 will be used. Allowed values: `DEFAULT` `PKCS8` `OPENSSH` `TSS2` `CLASSIC`
        :param pulumi.Input[str] type: The key type used. The current DEFAULT type is ECDSA_P256. Allowed values: `DEFAULT` `ECDSA_P256` `ECDSA_P384` `ECDSA_P521` `RSA_2048` `RSA_3072` `RSA_4096` `ED25519`
        :param pulumi.Input[str] protection: Whether to use a hardware module to store the private key for a workload certificate. If set to `NONE` no hardware module will be used. If set to `DEFAULT` a hardware module will only be used with format `TSS2`. `HARDWARE_WITH_FALLBACK` can only be used with the key format `DEFAULT`. Allowed values: `DEFAULT` `NONE` `HARDWARE` `HARDWARE_WITH_FALLBACK` `HARDWARE_ATTESTED`
        :param pulumi.Input[str] pub_file: A CSR or SSH public key to use instead of generating one.
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "type", type)
        if protection is not None:
            pulumi.set(__self__, "protection", protection)
        if pub_file is not None:
            pulumi.set(__self__, "pub_file", pub_file)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        """
        The format used to encode the private key. For X509 keys the default format is PKCS#8. The classic format is PKCS#1 for RSA keys, SEC 1 for ECDSA keys, and PKCS#8 for ED25519 keys. For SSH keys the default format is always the OPENSSH format. When a hardware module is used to store the keys the default will be a JSON representation of the key, except on Linux where tss2 will be used. Allowed values: `DEFAULT` `PKCS8` `OPENSSH` `TSS2` `CLASSIC`
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The key type used. The current DEFAULT type is ECDSA_P256. Allowed values: `DEFAULT` `ECDSA_P256` `ECDSA_P384` `ECDSA_P521` `RSA_2048` `RSA_3072` `RSA_4096` `ED25519`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def protection(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to use a hardware module to store the private key for a workload certificate. If set to `NONE` no hardware module will be used. If set to `DEFAULT` a hardware module will only be used with format `TSS2`. `HARDWARE_WITH_FALLBACK` can only be used with the key format `DEFAULT`. Allowed values: `DEFAULT` `NONE` `HARDWARE` `HARDWARE_WITH_FALLBACK` `HARDWARE_ATTESTED`
        """
        return pulumi.get(self, "protection")

    @protection.setter
    def protection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protection", value)

    @property
    @pulumi.getter(name="pubFile")
    def pub_file(self) -> Optional[pulumi.Input[str]]:
        """
        A CSR or SSH public key to use instead of generating one.
        """
        return pulumi.get(self, "pub_file")

    @pub_file.setter
    def pub_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pub_file", value)


if not MYPY:
    class DeviceCollectionAccountReloadInfoArgsDict(TypedDict):
        method: pulumi.Input[str]
        """
        Ways an endpoint can reload a certificate. `AUTOMATIC` means the process is able to detect and reload new certificates automatically. `CUSTOM` means a custom command must be run to trigger the workload to reload the certificates. `SIGNAL` will configure the agent to send a signal to the process in `pidFile`. `DBUS` will use the systemd system bus to issue a `try-reload-or-restart` job for unit specified by `unitName`. `PLATFORM` uses a method specific to the operating system. Allowed values: `AUTOMATIC` `CUSTOM` `SIGNAL` `DBUS` `PLATFORM`
        """
        pid_file: NotRequired[pulumi.Input[str]]
        """
        File that holds the pid of the process to signal. Required when method is SIGNAL.
        """
        signal: NotRequired[pulumi.Input[float]]
        """
        The signal to send to a process when a certificate should be reloaded. Required when method is SIGNAL.
        """
        unit_name: NotRequired[pulumi.Input[str]]
        """
        The systemd unit name to reload when a certificate should be reloaded. Required when method is DBUS.
        """
elif False:
    DeviceCollectionAccountReloadInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceCollectionAccountReloadInfoArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[str],
                 pid_file: Optional[pulumi.Input[str]] = None,
                 signal: Optional[pulumi.Input[float]] = None,
                 unit_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] method: Ways an endpoint can reload a certificate. `AUTOMATIC` means the process is able to detect and reload new certificates automatically. `CUSTOM` means a custom command must be run to trigger the workload to reload the certificates. `SIGNAL` will configure the agent to send a signal to the process in `pidFile`. `DBUS` will use the systemd system bus to issue a `try-reload-or-restart` job for unit specified by `unitName`. `PLATFORM` uses a method specific to the operating system. Allowed values: `AUTOMATIC` `CUSTOM` `SIGNAL` `DBUS` `PLATFORM`
        :param pulumi.Input[str] pid_file: File that holds the pid of the process to signal. Required when method is SIGNAL.
        :param pulumi.Input[float] signal: The signal to send to a process when a certificate should be reloaded. Required when method is SIGNAL.
        :param pulumi.Input[str] unit_name: The systemd unit name to reload when a certificate should be reloaded. Required when method is DBUS.
        """
        pulumi.set(__self__, "method", method)
        if pid_file is not None:
            pulumi.set(__self__, "pid_file", pid_file)
        if signal is not None:
            pulumi.set(__self__, "signal", signal)
        if unit_name is not None:
            pulumi.set(__self__, "unit_name", unit_name)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[str]:
        """
        Ways an endpoint can reload a certificate. `AUTOMATIC` means the process is able to detect and reload new certificates automatically. `CUSTOM` means a custom command must be run to trigger the workload to reload the certificates. `SIGNAL` will configure the agent to send a signal to the process in `pidFile`. `DBUS` will use the systemd system bus to issue a `try-reload-or-restart` job for unit specified by `unitName`. `PLATFORM` uses a method specific to the operating system. Allowed values: `AUTOMATIC` `CUSTOM` `SIGNAL` `DBUS` `PLATFORM`
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="pidFile")
    def pid_file(self) -> Optional[pulumi.Input[str]]:
        """
        File that holds the pid of the process to signal. Required when method is SIGNAL.
        """
        return pulumi.get(self, "pid_file")

    @pid_file.setter
    def pid_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pid_file", value)

    @property
    @pulumi.getter
    def signal(self) -> Optional[pulumi.Input[float]]:
        """
        The signal to send to a process when a certificate should be reloaded. Required when method is SIGNAL.
        """
        return pulumi.get(self, "signal")

    @signal.setter
    def signal(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "signal", value)

    @property
    @pulumi.getter(name="unitName")
    def unit_name(self) -> Optional[pulumi.Input[str]]:
        """
        The systemd unit name to reload when a certificate should be reloaded. Required when method is DBUS.
        """
        return pulumi.get(self, "unit_name")

    @unit_name.setter
    def unit_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unit_name", value)


if not MYPY:
    class DeviceCollectionAwsVmArgsDict(TypedDict):
        accounts: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The list of AWS account IDs that are allowed to use an AWS cloud provisioner.
        """
        disable_custom_sans: NotRequired[pulumi.Input[bool]]
        """
        By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid. These are the private IP and the DNS ip-<private-ip>.<region>.compute.internal.
        """
elif False:
    DeviceCollectionAwsVmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceCollectionAwsVmArgs:
    def __init__(__self__, *,
                 accounts: pulumi.Input[Sequence[pulumi.Input[str]]],
                 disable_custom_sans: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] accounts: The list of AWS account IDs that are allowed to use an AWS cloud provisioner.
        :param pulumi.Input[bool] disable_custom_sans: By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid. These are the private IP and the DNS ip-<private-ip>.<region>.compute.internal.
        """
        pulumi.set(__self__, "accounts", accounts)
        if disable_custom_sans is not None:
            pulumi.set(__self__, "disable_custom_sans", disable_custom_sans)

    @property
    @pulumi.getter
    def accounts(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The list of AWS account IDs that are allowed to use an AWS cloud provisioner.
        """
        return pulumi.get(self, "accounts")

    @accounts.setter
    def accounts(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "accounts", value)

    @property
    @pulumi.getter(name="disableCustomSans")
    def disable_custom_sans(self) -> Optional[pulumi.Input[bool]]:
        """
        By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid. These are the private IP and the DNS ip-<private-ip>.<region>.compute.internal.
        """
        return pulumi.get(self, "disable_custom_sans")

    @disable_custom_sans.setter
    def disable_custom_sans(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_custom_sans", value)


if not MYPY:
    class DeviceCollectionAzureVmArgsDict(TypedDict):
        resource_groups: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The list of resource group names that are allowed to use this provisioner.
        """
        tenant_id: pulumi.Input[str]
        """
        The Azure account tenant ID for this provisioner. This ID is the Directory ID available in the Azure Active Directory properties.
        """
        audience: NotRequired[pulumi.Input[str]]
        """
        Defaults to https://management.azure.com/ but it can be changed if necessary.
        """
        disable_custom_sans: NotRequired[pulumi.Input[bool]]
        """
        By default custom SANs are valid, but if this option is set to `true` only the SANs available in the token will be valid, in Azure only the virtual machine name is available.
        """
elif False:
    DeviceCollectionAzureVmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceCollectionAzureVmArgs:
    def __init__(__self__, *,
                 resource_groups: pulumi.Input[Sequence[pulumi.Input[str]]],
                 tenant_id: pulumi.Input[str],
                 audience: Optional[pulumi.Input[str]] = None,
                 disable_custom_sans: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: The list of resource group names that are allowed to use this provisioner.
        :param pulumi.Input[str] tenant_id: The Azure account tenant ID for this provisioner. This ID is the Directory ID available in the Azure Active Directory properties.
        :param pulumi.Input[str] audience: Defaults to https://management.azure.com/ but it can be changed if necessary.
        :param pulumi.Input[bool] disable_custom_sans: By default custom SANs are valid, but if this option is set to `true` only the SANs available in the token will be valid, in Azure only the virtual machine name is available.
        """
        pulumi.set(__self__, "resource_groups", resource_groups)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if audience is not None:
            pulumi.set(__self__, "audience", audience)
        if disable_custom_sans is not None:
            pulumi.set(__self__, "disable_custom_sans", disable_custom_sans)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The list of resource group names that are allowed to use this provisioner.
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "resource_groups", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[str]:
        """
        The Azure account tenant ID for this provisioner. This ID is the Directory ID available in the Azure Active Directory properties.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter
    def audience(self) -> Optional[pulumi.Input[str]]:
        """
        Defaults to https://management.azure.com/ but it can be changed if necessary.
        """
        return pulumi.get(self, "audience")

    @audience.setter
    def audience(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audience", value)

    @property
    @pulumi.getter(name="disableCustomSans")
    def disable_custom_sans(self) -> Optional[pulumi.Input[bool]]:
        """
        By default custom SANs are valid, but if this option is set to `true` only the SANs available in the token will be valid, in Azure only the virtual machine name is available.
        """
        return pulumi.get(self, "disable_custom_sans")

    @disable_custom_sans.setter
    def disable_custom_sans(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_custom_sans", value)


if not MYPY:
    class DeviceCollectionGcpVmArgsDict(TypedDict):
        disable_custom_sans: NotRequired[pulumi.Input[bool]]
        """
        By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid, these are the DNS `<instance-name>.c.<project-id>.internal` and `<instance-name>.<zone>.c.<project-id>.internal`.
        """
        project_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of project identifiers that are allowed to use a GCP cloud provisioner.
        """
        service_accounts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of service accounts that are allowed to use a GCP cloud provisioner.
        """
elif False:
    DeviceCollectionGcpVmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceCollectionGcpVmArgs:
    def __init__(__self__, *,
                 disable_custom_sans: Optional[pulumi.Input[bool]] = None,
                 project_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_accounts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] disable_custom_sans: By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid, these are the DNS `<instance-name>.c.<project-id>.internal` and `<instance-name>.<zone>.c.<project-id>.internal`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] project_ids: The list of project identifiers that are allowed to use a GCP cloud provisioner.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_accounts: The list of service accounts that are allowed to use a GCP cloud provisioner.
        """
        if disable_custom_sans is not None:
            pulumi.set(__self__, "disable_custom_sans", disable_custom_sans)
        if project_ids is not None:
            pulumi.set(__self__, "project_ids", project_ids)
        if service_accounts is not None:
            pulumi.set(__self__, "service_accounts", service_accounts)

    @property
    @pulumi.getter(name="disableCustomSans")
    def disable_custom_sans(self) -> Optional[pulumi.Input[bool]]:
        """
        By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid, these are the DNS `<instance-name>.c.<project-id>.internal` and `<instance-name>.<zone>.c.<project-id>.internal`.
        """
        return pulumi.get(self, "disable_custom_sans")

    @disable_custom_sans.setter
    def disable_custom_sans(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_custom_sans", value)

    @property
    @pulumi.getter(name="projectIds")
    def project_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of project identifiers that are allowed to use a GCP cloud provisioner.
        """
        return pulumi.get(self, "project_ids")

    @project_ids.setter
    def project_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "project_ids", value)

    @property
    @pulumi.getter(name="serviceAccounts")
    def service_accounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of service accounts that are allowed to use a GCP cloud provisioner.
        """
        return pulumi.get(self, "service_accounts")

    @service_accounts.setter
    def service_accounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "service_accounts", value)


if not MYPY:
    class DeviceCollectionTpmArgsDict(TypedDict):
        attestor_intermediates: NotRequired[pulumi.Input[str]]
        """
        The pem-encoded list of intermediate certificates used to build a chain of trust to verify the attestation certificates submitted by agents. Ignored if the team already has an attestation authority.
        """
        attestor_roots: NotRequired[pulumi.Input[str]]
        """
        The pem-encoded list of certificates used to verify the attestation certificates submitted by agents. Ignored if the team already has an attestation authority. Required if the team does not already have an attestation authority.
        """
        force_cn: NotRequired[pulumi.Input[bool]]
        """
        Force one of the SANs to become the Common Name, if a Common Name is not provided.
        """
        require_eab: NotRequired[pulumi.Input[bool]]
        """
        Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner.
        """
elif False:
    DeviceCollectionTpmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceCollectionTpmArgs:
    def __init__(__self__, *,
                 attestor_intermediates: Optional[pulumi.Input[str]] = None,
                 attestor_roots: Optional[pulumi.Input[str]] = None,
                 force_cn: Optional[pulumi.Input[bool]] = None,
                 require_eab: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] attestor_intermediates: The pem-encoded list of intermediate certificates used to build a chain of trust to verify the attestation certificates submitted by agents. Ignored if the team already has an attestation authority.
        :param pulumi.Input[str] attestor_roots: The pem-encoded list of certificates used to verify the attestation certificates submitted by agents. Ignored if the team already has an attestation authority. Required if the team does not already have an attestation authority.
        :param pulumi.Input[bool] force_cn: Force one of the SANs to become the Common Name, if a Common Name is not provided.
        :param pulumi.Input[bool] require_eab: Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner.
        """
        if attestor_intermediates is not None:
            pulumi.set(__self__, "attestor_intermediates", attestor_intermediates)
        if attestor_roots is not None:
            pulumi.set(__self__, "attestor_roots", attestor_roots)
        if force_cn is not None:
            pulumi.set(__self__, "force_cn", force_cn)
        if require_eab is not None:
            pulumi.set(__self__, "require_eab", require_eab)

    @property
    @pulumi.getter(name="attestorIntermediates")
    def attestor_intermediates(self) -> Optional[pulumi.Input[str]]:
        """
        The pem-encoded list of intermediate certificates used to build a chain of trust to verify the attestation certificates submitted by agents. Ignored if the team already has an attestation authority.
        """
        return pulumi.get(self, "attestor_intermediates")

    @attestor_intermediates.setter
    def attestor_intermediates(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attestor_intermediates", value)

    @property
    @pulumi.getter(name="attestorRoots")
    def attestor_roots(self) -> Optional[pulumi.Input[str]]:
        """
        The pem-encoded list of certificates used to verify the attestation certificates submitted by agents. Ignored if the team already has an attestation authority. Required if the team does not already have an attestation authority.
        """
        return pulumi.get(self, "attestor_roots")

    @attestor_roots.setter
    def attestor_roots(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attestor_roots", value)

    @property
    @pulumi.getter(name="forceCn")
    def force_cn(self) -> Optional[pulumi.Input[bool]]:
        """
        Force one of the SANs to become the Common Name, if a Common Name is not provided.
        """
        return pulumi.get(self, "force_cn")

    @force_cn.setter
    def force_cn(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force_cn", value)

    @property
    @pulumi.getter(name="requireEab")
    def require_eab(self) -> Optional[pulumi.Input[bool]]:
        """
        Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner.
        """
        return pulumi.get(self, "require_eab")

    @require_eab.setter
    def require_eab(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_eab", value)


if not MYPY:
    class ProviderClientCertificateArgsDict(TypedDict):
        certificate: pulumi.Input[str]
        """
        The PEM encoded certificate signed by your trusted root.
        """
        private_key: pulumi.Input[str]
        """
        The PEM encoded private key
        """
        team_id: pulumi.Input[str]
        """
        Your team's UUID
        """
elif False:
    ProviderClientCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProviderClientCertificateArgs:
    def __init__(__self__, *,
                 certificate: pulumi.Input[str],
                 private_key: pulumi.Input[str],
                 team_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate: The PEM encoded certificate signed by your trusted root.
        :param pulumi.Input[str] private_key: The PEM encoded private key
        :param pulumi.Input[str] team_id: Your team's UUID
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "team_id", team_id)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input[str]:
        """
        The PEM encoded certificate signed by your trusted root.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[str]:
        """
        The PEM encoded private key
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> pulumi.Input[str]:
        """
        Your team's UUID
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "team_id", value)


if not MYPY:
    class ProvisionerAcmeArgsDict(TypedDict):
        challenges: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Which ACME challenge types are allowed. Allowed values: `http-01` `dns-01` `tls-alpn-01`
        """
        require_eab: pulumi.Input[bool]
        """
        Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner. Must be `true` for all new provisioners.
        """
        force_cn: NotRequired[pulumi.Input[bool]]
        """
        Force one of the SANs to become the Common Name, if a Common Name is not provided.
        """
elif False:
    ProvisionerAcmeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProvisionerAcmeArgs:
    def __init__(__self__, *,
                 challenges: pulumi.Input[Sequence[pulumi.Input[str]]],
                 require_eab: pulumi.Input[bool],
                 force_cn: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] challenges: Which ACME challenge types are allowed. Allowed values: `http-01` `dns-01` `tls-alpn-01`
        :param pulumi.Input[bool] require_eab: Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner. Must be `true` for all new provisioners.
        :param pulumi.Input[bool] force_cn: Force one of the SANs to become the Common Name, if a Common Name is not provided.
        """
        pulumi.set(__self__, "challenges", challenges)
        pulumi.set(__self__, "require_eab", require_eab)
        if force_cn is not None:
            pulumi.set(__self__, "force_cn", force_cn)

    @property
    @pulumi.getter
    def challenges(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Which ACME challenge types are allowed. Allowed values: `http-01` `dns-01` `tls-alpn-01`
        """
        return pulumi.get(self, "challenges")

    @challenges.setter
    def challenges(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "challenges", value)

    @property
    @pulumi.getter(name="requireEab")
    def require_eab(self) -> pulumi.Input[bool]:
        """
        Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner. Must be `true` for all new provisioners.
        """
        return pulumi.get(self, "require_eab")

    @require_eab.setter
    def require_eab(self, value: pulumi.Input[bool]):
        pulumi.set(self, "require_eab", value)

    @property
    @pulumi.getter(name="forceCn")
    def force_cn(self) -> Optional[pulumi.Input[bool]]:
        """
        Force one of the SANs to become the Common Name, if a Common Name is not provided.
        """
        return pulumi.get(self, "force_cn")

    @force_cn.setter
    def force_cn(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force_cn", value)


if not MYPY:
    class ProvisionerAcmeAttestationArgsDict(TypedDict):
        attestation_formats: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The allowed attestation formats for the device-attest-01 challenge. Valid values are `apple`, `step`, and `tpm`. The apple format is for Apple devices, and adds trust for Apple's CAs. The step format is for non-TPM devices that can issue attestation certificates, such as YubiKey PIV. It adds trust for Yubico's root CA. The tpm format is for TPMs and does not trust any CAs by default. Allowed values: `apple` `step` `tpm`
        """
        attestation_roots: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A trust bundle of root certificates in PEM format that will be used to verify attestation certificates. The default value depends on the value of attestationFormats. If provided, this PEM bundle will override the CA trust established by setting attestationFormats to apple or step. At least one root certificate is required when using the tpm attestationFormat.
        """
        force_cn: NotRequired[pulumi.Input[bool]]
        """
        Force one of the SANs to become the Common Name, if a Common Name is not provided.
        """
        require_eab: NotRequired[pulumi.Input[bool]]
        """
        Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner.
        """
elif False:
    ProvisionerAcmeAttestationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProvisionerAcmeAttestationArgs:
    def __init__(__self__, *,
                 attestation_formats: pulumi.Input[Sequence[pulumi.Input[str]]],
                 attestation_roots: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 force_cn: Optional[pulumi.Input[bool]] = None,
                 require_eab: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] attestation_formats: The allowed attestation formats for the device-attest-01 challenge. Valid values are `apple`, `step`, and `tpm`. The apple format is for Apple devices, and adds trust for Apple's CAs. The step format is for non-TPM devices that can issue attestation certificates, such as YubiKey PIV. It adds trust for Yubico's root CA. The tpm format is for TPMs and does not trust any CAs by default. Allowed values: `apple` `step` `tpm`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] attestation_roots: A trust bundle of root certificates in PEM format that will be used to verify attestation certificates. The default value depends on the value of attestationFormats. If provided, this PEM bundle will override the CA trust established by setting attestationFormats to apple or step. At least one root certificate is required when using the tpm attestationFormat.
        :param pulumi.Input[bool] force_cn: Force one of the SANs to become the Common Name, if a Common Name is not provided.
        :param pulumi.Input[bool] require_eab: Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner.
        """
        pulumi.set(__self__, "attestation_formats", attestation_formats)
        if attestation_roots is not None:
            pulumi.set(__self__, "attestation_roots", attestation_roots)
        if force_cn is not None:
            pulumi.set(__self__, "force_cn", force_cn)
        if require_eab is not None:
            pulumi.set(__self__, "require_eab", require_eab)

    @property
    @pulumi.getter(name="attestationFormats")
    def attestation_formats(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The allowed attestation formats for the device-attest-01 challenge. Valid values are `apple`, `step`, and `tpm`. The apple format is for Apple devices, and adds trust for Apple's CAs. The step format is for non-TPM devices that can issue attestation certificates, such as YubiKey PIV. It adds trust for Yubico's root CA. The tpm format is for TPMs and does not trust any CAs by default. Allowed values: `apple` `step` `tpm`
        """
        return pulumi.get(self, "attestation_formats")

    @attestation_formats.setter
    def attestation_formats(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "attestation_formats", value)

    @property
    @pulumi.getter(name="attestationRoots")
    def attestation_roots(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A trust bundle of root certificates in PEM format that will be used to verify attestation certificates. The default value depends on the value of attestationFormats. If provided, this PEM bundle will override the CA trust established by setting attestationFormats to apple or step. At least one root certificate is required when using the tpm attestationFormat.
        """
        return pulumi.get(self, "attestation_roots")

    @attestation_roots.setter
    def attestation_roots(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "attestation_roots", value)

    @property
    @pulumi.getter(name="forceCn")
    def force_cn(self) -> Optional[pulumi.Input[bool]]:
        """
        Force one of the SANs to become the Common Name, if a Common Name is not provided.
        """
        return pulumi.get(self, "force_cn")

    @force_cn.setter
    def force_cn(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force_cn", value)

    @property
    @pulumi.getter(name="requireEab")
    def require_eab(self) -> Optional[pulumi.Input[bool]]:
        """
        Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner.
        """
        return pulumi.get(self, "require_eab")

    @require_eab.setter
    def require_eab(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_eab", value)


if not MYPY:
    class ProvisionerAwsArgsDict(TypedDict):
        accounts: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The list of AWS account IDs that are allowed to use an AWS cloud provisioner.
        """
        disable_custom_sans: NotRequired[pulumi.Input[bool]]
        """
        By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid. These are the private IP and the DNS ip-<private-ip>.<region>.compute.internal.
        """
        disable_trust_on_first_use: NotRequired[pulumi.Input[bool]]
        """
        By default only one certificate will be granted per instance, but if the option is set to `true` this limit is not set and different tokens can be used to get different certificates.
        """
        instance_age: NotRequired[pulumi.Input[str]]
        """
        The maximum age of an instance that should be allowed to obtain a certificate. Limits certificate issuance to new instances to mitigate the risk of credential-misuse from instances that don't need a certificate. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
elif False:
    ProvisionerAwsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProvisionerAwsArgs:
    def __init__(__self__, *,
                 accounts: pulumi.Input[Sequence[pulumi.Input[str]]],
                 disable_custom_sans: Optional[pulumi.Input[bool]] = None,
                 disable_trust_on_first_use: Optional[pulumi.Input[bool]] = None,
                 instance_age: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] accounts: The list of AWS account IDs that are allowed to use an AWS cloud provisioner.
        :param pulumi.Input[bool] disable_custom_sans: By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid. These are the private IP and the DNS ip-<private-ip>.<region>.compute.internal.
        :param pulumi.Input[bool] disable_trust_on_first_use: By default only one certificate will be granted per instance, but if the option is set to `true` this limit is not set and different tokens can be used to get different certificates.
        :param pulumi.Input[str] instance_age: The maximum age of an instance that should be allowed to obtain a certificate. Limits certificate issuance to new instances to mitigate the risk of credential-misuse from instances that don't need a certificate. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        pulumi.set(__self__, "accounts", accounts)
        if disable_custom_sans is not None:
            pulumi.set(__self__, "disable_custom_sans", disable_custom_sans)
        if disable_trust_on_first_use is not None:
            pulumi.set(__self__, "disable_trust_on_first_use", disable_trust_on_first_use)
        if instance_age is not None:
            pulumi.set(__self__, "instance_age", instance_age)

    @property
    @pulumi.getter
    def accounts(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The list of AWS account IDs that are allowed to use an AWS cloud provisioner.
        """
        return pulumi.get(self, "accounts")

    @accounts.setter
    def accounts(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "accounts", value)

    @property
    @pulumi.getter(name="disableCustomSans")
    def disable_custom_sans(self) -> Optional[pulumi.Input[bool]]:
        """
        By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid. These are the private IP and the DNS ip-<private-ip>.<region>.compute.internal.
        """
        return pulumi.get(self, "disable_custom_sans")

    @disable_custom_sans.setter
    def disable_custom_sans(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_custom_sans", value)

    @property
    @pulumi.getter(name="disableTrustOnFirstUse")
    def disable_trust_on_first_use(self) -> Optional[pulumi.Input[bool]]:
        """
        By default only one certificate will be granted per instance, but if the option is set to `true` this limit is not set and different tokens can be used to get different certificates.
        """
        return pulumi.get(self, "disable_trust_on_first_use")

    @disable_trust_on_first_use.setter
    def disable_trust_on_first_use(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_trust_on_first_use", value)

    @property
    @pulumi.getter(name="instanceAge")
    def instance_age(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum age of an instance that should be allowed to obtain a certificate. Limits certificate issuance to new instances to mitigate the risk of credential-misuse from instances that don't need a certificate. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "instance_age")

    @instance_age.setter
    def instance_age(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_age", value)


if not MYPY:
    class ProvisionerAzureArgsDict(TypedDict):
        resource_groups: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The list of resource group names that are allowed to use this provisioner.
        """
        tenant_id: pulumi.Input[str]
        """
        The Azure account tenant ID for this provisioner. This ID is the Directory ID available in the Azure Active Directory properties.
        """
        audience: NotRequired[pulumi.Input[str]]
        """
        Defaults to https://management.azure.com/ but it can be changed if necessary.
        """
        disable_custom_sans: NotRequired[pulumi.Input[bool]]
        """
        By default custom SANs are valid, but if this option is set to `true` only the SANs available in the token will be valid, in Azure only the virtual machine name is available.
        """
        disable_trust_on_first_use: NotRequired[pulumi.Input[bool]]
        """
        By default only one certificate will be granted per instance, but if the option is set to true this limit is not set and different tokens can be used to get different certificates.
        """
elif False:
    ProvisionerAzureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProvisionerAzureArgs:
    def __init__(__self__, *,
                 resource_groups: pulumi.Input[Sequence[pulumi.Input[str]]],
                 tenant_id: pulumi.Input[str],
                 audience: Optional[pulumi.Input[str]] = None,
                 disable_custom_sans: Optional[pulumi.Input[bool]] = None,
                 disable_trust_on_first_use: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: The list of resource group names that are allowed to use this provisioner.
        :param pulumi.Input[str] tenant_id: The Azure account tenant ID for this provisioner. This ID is the Directory ID available in the Azure Active Directory properties.
        :param pulumi.Input[str] audience: Defaults to https://management.azure.com/ but it can be changed if necessary.
        :param pulumi.Input[bool] disable_custom_sans: By default custom SANs are valid, but if this option is set to `true` only the SANs available in the token will be valid, in Azure only the virtual machine name is available.
        :param pulumi.Input[bool] disable_trust_on_first_use: By default only one certificate will be granted per instance, but if the option is set to true this limit is not set and different tokens can be used to get different certificates.
        """
        pulumi.set(__self__, "resource_groups", resource_groups)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if audience is not None:
            pulumi.set(__self__, "audience", audience)
        if disable_custom_sans is not None:
            pulumi.set(__self__, "disable_custom_sans", disable_custom_sans)
        if disable_trust_on_first_use is not None:
            pulumi.set(__self__, "disable_trust_on_first_use", disable_trust_on_first_use)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The list of resource group names that are allowed to use this provisioner.
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "resource_groups", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[str]:
        """
        The Azure account tenant ID for this provisioner. This ID is the Directory ID available in the Azure Active Directory properties.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter
    def audience(self) -> Optional[pulumi.Input[str]]:
        """
        Defaults to https://management.azure.com/ but it can be changed if necessary.
        """
        return pulumi.get(self, "audience")

    @audience.setter
    def audience(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audience", value)

    @property
    @pulumi.getter(name="disableCustomSans")
    def disable_custom_sans(self) -> Optional[pulumi.Input[bool]]:
        """
        By default custom SANs are valid, but if this option is set to `true` only the SANs available in the token will be valid, in Azure only the virtual machine name is available.
        """
        return pulumi.get(self, "disable_custom_sans")

    @disable_custom_sans.setter
    def disable_custom_sans(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_custom_sans", value)

    @property
    @pulumi.getter(name="disableTrustOnFirstUse")
    def disable_trust_on_first_use(self) -> Optional[pulumi.Input[bool]]:
        """
        By default only one certificate will be granted per instance, but if the option is set to true this limit is not set and different tokens can be used to get different certificates.
        """
        return pulumi.get(self, "disable_trust_on_first_use")

    @disable_trust_on_first_use.setter
    def disable_trust_on_first_use(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_trust_on_first_use", value)


if not MYPY:
    class ProvisionerClaimsArgsDict(TypedDict):
        allow_renewal_after_expiry: NotRequired[pulumi.Input[bool]]
        """
        Allow renewals for expired certificates generated by this provisioner.
        """
        default_host_ssh_cert_duration: NotRequired[pulumi.Input[str]]
        """
        The default duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        default_tls_cert_duration: NotRequired[pulumi.Input[str]]
        """
        The default duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        default_user_ssh_cert_duration: NotRequired[pulumi.Input[str]]
        """
        The default duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        disable_renewal: NotRequired[pulumi.Input[bool]]
        """
        Disable renewal for all certificates generated by this provisioner.
        """
        enable_ssh_ca: NotRequired[pulumi.Input[bool]]
        """
        Allow this provisioner to be used to generate SSH certificates.
        """
        max_host_ssh_cert_duration: NotRequired[pulumi.Input[str]]
        """
        The maximum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        max_tls_cert_duration: NotRequired[pulumi.Input[str]]
        """
        The maximum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        max_user_ssh_cert_duration: NotRequired[pulumi.Input[str]]
        """
        The maximum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        min_host_ssh_cert_duration: NotRequired[pulumi.Input[str]]
        """
        The minimum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        min_tls_cert_duration: NotRequired[pulumi.Input[str]]
        """
        The minimum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        min_user_ssh_cert_duration: NotRequired[pulumi.Input[str]]
        """
        The minimum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
elif False:
    ProvisionerClaimsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProvisionerClaimsArgs:
    def __init__(__self__, *,
                 allow_renewal_after_expiry: Optional[pulumi.Input[bool]] = None,
                 default_host_ssh_cert_duration: Optional[pulumi.Input[str]] = None,
                 default_tls_cert_duration: Optional[pulumi.Input[str]] = None,
                 default_user_ssh_cert_duration: Optional[pulumi.Input[str]] = None,
                 disable_renewal: Optional[pulumi.Input[bool]] = None,
                 enable_ssh_ca: Optional[pulumi.Input[bool]] = None,
                 max_host_ssh_cert_duration: Optional[pulumi.Input[str]] = None,
                 max_tls_cert_duration: Optional[pulumi.Input[str]] = None,
                 max_user_ssh_cert_duration: Optional[pulumi.Input[str]] = None,
                 min_host_ssh_cert_duration: Optional[pulumi.Input[str]] = None,
                 min_tls_cert_duration: Optional[pulumi.Input[str]] = None,
                 min_user_ssh_cert_duration: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] allow_renewal_after_expiry: Allow renewals for expired certificates generated by this provisioner.
        :param pulumi.Input[str] default_host_ssh_cert_duration: The default duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param pulumi.Input[str] default_tls_cert_duration: The default duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param pulumi.Input[str] default_user_ssh_cert_duration: The default duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param pulumi.Input[bool] disable_renewal: Disable renewal for all certificates generated by this provisioner.
        :param pulumi.Input[bool] enable_ssh_ca: Allow this provisioner to be used to generate SSH certificates.
        :param pulumi.Input[str] max_host_ssh_cert_duration: The maximum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param pulumi.Input[str] max_tls_cert_duration: The maximum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param pulumi.Input[str] max_user_ssh_cert_duration: The maximum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param pulumi.Input[str] min_host_ssh_cert_duration: The minimum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param pulumi.Input[str] min_tls_cert_duration: The minimum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param pulumi.Input[str] min_user_ssh_cert_duration: The minimum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        if allow_renewal_after_expiry is not None:
            pulumi.set(__self__, "allow_renewal_after_expiry", allow_renewal_after_expiry)
        if default_host_ssh_cert_duration is not None:
            pulumi.set(__self__, "default_host_ssh_cert_duration", default_host_ssh_cert_duration)
        if default_tls_cert_duration is not None:
            pulumi.set(__self__, "default_tls_cert_duration", default_tls_cert_duration)
        if default_user_ssh_cert_duration is not None:
            pulumi.set(__self__, "default_user_ssh_cert_duration", default_user_ssh_cert_duration)
        if disable_renewal is not None:
            pulumi.set(__self__, "disable_renewal", disable_renewal)
        if enable_ssh_ca is not None:
            pulumi.set(__self__, "enable_ssh_ca", enable_ssh_ca)
        if max_host_ssh_cert_duration is not None:
            pulumi.set(__self__, "max_host_ssh_cert_duration", max_host_ssh_cert_duration)
        if max_tls_cert_duration is not None:
            pulumi.set(__self__, "max_tls_cert_duration", max_tls_cert_duration)
        if max_user_ssh_cert_duration is not None:
            pulumi.set(__self__, "max_user_ssh_cert_duration", max_user_ssh_cert_duration)
        if min_host_ssh_cert_duration is not None:
            pulumi.set(__self__, "min_host_ssh_cert_duration", min_host_ssh_cert_duration)
        if min_tls_cert_duration is not None:
            pulumi.set(__self__, "min_tls_cert_duration", min_tls_cert_duration)
        if min_user_ssh_cert_duration is not None:
            pulumi.set(__self__, "min_user_ssh_cert_duration", min_user_ssh_cert_duration)

    @property
    @pulumi.getter(name="allowRenewalAfterExpiry")
    def allow_renewal_after_expiry(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow renewals for expired certificates generated by this provisioner.
        """
        return pulumi.get(self, "allow_renewal_after_expiry")

    @allow_renewal_after_expiry.setter
    def allow_renewal_after_expiry(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_renewal_after_expiry", value)

    @property
    @pulumi.getter(name="defaultHostSshCertDuration")
    def default_host_ssh_cert_duration(self) -> Optional[pulumi.Input[str]]:
        """
        The default duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "default_host_ssh_cert_duration")

    @default_host_ssh_cert_duration.setter
    def default_host_ssh_cert_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_host_ssh_cert_duration", value)

    @property
    @pulumi.getter(name="defaultTlsCertDuration")
    def default_tls_cert_duration(self) -> Optional[pulumi.Input[str]]:
        """
        The default duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "default_tls_cert_duration")

    @default_tls_cert_duration.setter
    def default_tls_cert_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_tls_cert_duration", value)

    @property
    @pulumi.getter(name="defaultUserSshCertDuration")
    def default_user_ssh_cert_duration(self) -> Optional[pulumi.Input[str]]:
        """
        The default duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "default_user_ssh_cert_duration")

    @default_user_ssh_cert_duration.setter
    def default_user_ssh_cert_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_user_ssh_cert_duration", value)

    @property
    @pulumi.getter(name="disableRenewal")
    def disable_renewal(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable renewal for all certificates generated by this provisioner.
        """
        return pulumi.get(self, "disable_renewal")

    @disable_renewal.setter
    def disable_renewal(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_renewal", value)

    @property
    @pulumi.getter(name="enableSshCa")
    def enable_ssh_ca(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow this provisioner to be used to generate SSH certificates.
        """
        return pulumi.get(self, "enable_ssh_ca")

    @enable_ssh_ca.setter
    def enable_ssh_ca(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_ssh_ca", value)

    @property
    @pulumi.getter(name="maxHostSshCertDuration")
    def max_host_ssh_cert_duration(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "max_host_ssh_cert_duration")

    @max_host_ssh_cert_duration.setter
    def max_host_ssh_cert_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_host_ssh_cert_duration", value)

    @property
    @pulumi.getter(name="maxTlsCertDuration")
    def max_tls_cert_duration(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "max_tls_cert_duration")

    @max_tls_cert_duration.setter
    def max_tls_cert_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_tls_cert_duration", value)

    @property
    @pulumi.getter(name="maxUserSshCertDuration")
    def max_user_ssh_cert_duration(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "max_user_ssh_cert_duration")

    @max_user_ssh_cert_duration.setter
    def max_user_ssh_cert_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_user_ssh_cert_duration", value)

    @property
    @pulumi.getter(name="minHostSshCertDuration")
    def min_host_ssh_cert_duration(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "min_host_ssh_cert_duration")

    @min_host_ssh_cert_duration.setter
    def min_host_ssh_cert_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_host_ssh_cert_duration", value)

    @property
    @pulumi.getter(name="minTlsCertDuration")
    def min_tls_cert_duration(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "min_tls_cert_duration")

    @min_tls_cert_duration.setter
    def min_tls_cert_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_tls_cert_duration", value)

    @property
    @pulumi.getter(name="minUserSshCertDuration")
    def min_user_ssh_cert_duration(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "min_user_ssh_cert_duration")

    @min_user_ssh_cert_duration.setter
    def min_user_ssh_cert_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_user_ssh_cert_duration", value)


if not MYPY:
    class ProvisionerGcpArgsDict(TypedDict):
        project_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The list of project identifiers that are allowed to use a GCP cloud provisioner.
        """
        service_accounts: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The list of service accounts that are allowed to use a GCP cloud provisioner.
        """
        disable_custom_sans: NotRequired[pulumi.Input[bool]]
        """
        By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid, these are the DNS `<instance-name>.c.<project-id>.internal` and `<instance-name>.<zone>.c.<project-id>.internal`.
        """
        disable_trust_on_first_use: NotRequired[pulumi.Input[bool]]
        """
        By default only one certificate will be granted per instance, but if the option is set to `true` this limit is not set and different tokens can be used to get different certificates.
        """
        instance_age: NotRequired[pulumi.Input[str]]
        """
        The maximum age of an instance that should be allowed to obtain a certificate. Limits certificate issuance to new instances to mitigate the risk of credential-misuse from instances that don't need a certificate. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
elif False:
    ProvisionerGcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProvisionerGcpArgs:
    def __init__(__self__, *,
                 project_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 service_accounts: pulumi.Input[Sequence[pulumi.Input[str]]],
                 disable_custom_sans: Optional[pulumi.Input[bool]] = None,
                 disable_trust_on_first_use: Optional[pulumi.Input[bool]] = None,
                 instance_age: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] project_ids: The list of project identifiers that are allowed to use a GCP cloud provisioner.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_accounts: The list of service accounts that are allowed to use a GCP cloud provisioner.
        :param pulumi.Input[bool] disable_custom_sans: By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid, these are the DNS `<instance-name>.c.<project-id>.internal` and `<instance-name>.<zone>.c.<project-id>.internal`.
        :param pulumi.Input[bool] disable_trust_on_first_use: By default only one certificate will be granted per instance, but if the option is set to `true` this limit is not set and different tokens can be used to get different certificates.
        :param pulumi.Input[str] instance_age: The maximum age of an instance that should be allowed to obtain a certificate. Limits certificate issuance to new instances to mitigate the risk of credential-misuse from instances that don't need a certificate. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        pulumi.set(__self__, "project_ids", project_ids)
        pulumi.set(__self__, "service_accounts", service_accounts)
        if disable_custom_sans is not None:
            pulumi.set(__self__, "disable_custom_sans", disable_custom_sans)
        if disable_trust_on_first_use is not None:
            pulumi.set(__self__, "disable_trust_on_first_use", disable_trust_on_first_use)
        if instance_age is not None:
            pulumi.set(__self__, "instance_age", instance_age)

    @property
    @pulumi.getter(name="projectIds")
    def project_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The list of project identifiers that are allowed to use a GCP cloud provisioner.
        """
        return pulumi.get(self, "project_ids")

    @project_ids.setter
    def project_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "project_ids", value)

    @property
    @pulumi.getter(name="serviceAccounts")
    def service_accounts(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The list of service accounts that are allowed to use a GCP cloud provisioner.
        """
        return pulumi.get(self, "service_accounts")

    @service_accounts.setter
    def service_accounts(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "service_accounts", value)

    @property
    @pulumi.getter(name="disableCustomSans")
    def disable_custom_sans(self) -> Optional[pulumi.Input[bool]]:
        """
        By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid, these are the DNS `<instance-name>.c.<project-id>.internal` and `<instance-name>.<zone>.c.<project-id>.internal`.
        """
        return pulumi.get(self, "disable_custom_sans")

    @disable_custom_sans.setter
    def disable_custom_sans(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_custom_sans", value)

    @property
    @pulumi.getter(name="disableTrustOnFirstUse")
    def disable_trust_on_first_use(self) -> Optional[pulumi.Input[bool]]:
        """
        By default only one certificate will be granted per instance, but if the option is set to `true` this limit is not set and different tokens can be used to get different certificates.
        """
        return pulumi.get(self, "disable_trust_on_first_use")

    @disable_trust_on_first_use.setter
    def disable_trust_on_first_use(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_trust_on_first_use", value)

    @property
    @pulumi.getter(name="instanceAge")
    def instance_age(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum age of an instance that should be allowed to obtain a certificate. Limits certificate issuance to new instances to mitigate the risk of credential-misuse from instances that don't need a certificate. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "instance_age")

    @instance_age.setter
    def instance_age(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_age", value)


if not MYPY:
    class ProvisionerJwkArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The public JSON web key.
        """
        encrypted_key: NotRequired[pulumi.Input[str]]
        """
        The JWE encrypted private key.
        """
elif False:
    ProvisionerJwkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProvisionerJwkArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 encrypted_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The public JSON web key.
        :param pulumi.Input[str] encrypted_key: The JWE encrypted private key.
        """
        pulumi.set(__self__, "key", key)
        if encrypted_key is not None:
            pulumi.set(__self__, "encrypted_key", encrypted_key)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The public JSON web key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="encryptedKey")
    def encrypted_key(self) -> Optional[pulumi.Input[str]]:
        """
        The JWE encrypted private key.
        """
        return pulumi.get(self, "encrypted_key")

    @encrypted_key.setter
    def encrypted_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encrypted_key", value)


if not MYPY:
    class ProvisionerOidcArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The id used to validate the audience in an OpenID Connect token.
        """
        configuration_endpoint: pulumi.Input[str]
        """
        OpenID Connect configuration URL.
        """
        admins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The emails of admin users in an OpenID Connect provisioner. These users will not have restrictions in the certificates to sign.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The secret used to obtain the OpenID Connect tokens.
        """
        domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The domains used to validate the email claim in an OpenID Connect provisioner.
        """
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The group list used to validate the groups extension in an OpenID Connect token.
        """
        listen_address: NotRequired[pulumi.Input[str]]
        """
        The callback address used in the OpenID Connect flow.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The tenant-id used to replace the templatized tenantid value in the OpenID Configuration.
        """
elif False:
    ProvisionerOidcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProvisionerOidcArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 configuration_endpoint: pulumi.Input[str],
                 admins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 listen_address: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The id used to validate the audience in an OpenID Connect token.
        :param pulumi.Input[str] configuration_endpoint: OpenID Connect configuration URL.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] admins: The emails of admin users in an OpenID Connect provisioner. These users will not have restrictions in the certificates to sign.
        :param pulumi.Input[str] client_secret: The secret used to obtain the OpenID Connect tokens.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] domains: The domains used to validate the email claim in an OpenID Connect provisioner.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] groups: The group list used to validate the groups extension in an OpenID Connect token.
        :param pulumi.Input[str] listen_address: The callback address used in the OpenID Connect flow.
        :param pulumi.Input[str] tenant_id: The tenant-id used to replace the templatized tenantid value in the OpenID Configuration.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "configuration_endpoint", configuration_endpoint)
        if admins is not None:
            pulumi.set(__self__, "admins", admins)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if domains is not None:
            pulumi.set(__self__, "domains", domains)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if listen_address is not None:
            pulumi.set(__self__, "listen_address", listen_address)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The id used to validate the audience in an OpenID Connect token.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="configurationEndpoint")
    def configuration_endpoint(self) -> pulumi.Input[str]:
        """
        OpenID Connect configuration URL.
        """
        return pulumi.get(self, "configuration_endpoint")

    @configuration_endpoint.setter
    def configuration_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "configuration_endpoint", value)

    @property
    @pulumi.getter
    def admins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The emails of admin users in an OpenID Connect provisioner. These users will not have restrictions in the certificates to sign.
        """
        return pulumi.get(self, "admins")

    @admins.setter
    def admins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "admins", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The secret used to obtain the OpenID Connect tokens.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The domains used to validate the email claim in an OpenID Connect provisioner.
        """
        return pulumi.get(self, "domains")

    @domains.setter
    def domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "domains", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The group list used to validate the groups extension in an OpenID Connect token.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter(name="listenAddress")
    def listen_address(self) -> Optional[pulumi.Input[str]]:
        """
        The callback address used in the OpenID Connect flow.
        """
        return pulumi.get(self, "listen_address")

    @listen_address.setter
    def listen_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "listen_address", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The tenant-id used to replace the templatized tenantid value in the OpenID Configuration.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class ProvisionerOptionsArgsDict(TypedDict):
        ssh: NotRequired[pulumi.Input['ProvisionerOptionsSshArgsDict']]
        """
        Options that apply when issuing SSH certificates
        """
        x509: NotRequired[pulumi.Input['ProvisionerOptionsX509ArgsDict']]
        """
        Options that apply when issuing x509 certificates.
        """
elif False:
    ProvisionerOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProvisionerOptionsArgs:
    def __init__(__self__, *,
                 ssh: Optional[pulumi.Input['ProvisionerOptionsSshArgs']] = None,
                 x509: Optional[pulumi.Input['ProvisionerOptionsX509Args']] = None):
        """
        :param pulumi.Input['ProvisionerOptionsSshArgs'] ssh: Options that apply when issuing SSH certificates
        :param pulumi.Input['ProvisionerOptionsX509Args'] x509: Options that apply when issuing x509 certificates.
        """
        if ssh is not None:
            pulumi.set(__self__, "ssh", ssh)
        if x509 is not None:
            pulumi.set(__self__, "x509", x509)

    @property
    @pulumi.getter
    def ssh(self) -> Optional[pulumi.Input['ProvisionerOptionsSshArgs']]:
        """
        Options that apply when issuing SSH certificates
        """
        return pulumi.get(self, "ssh")

    @ssh.setter
    def ssh(self, value: Optional[pulumi.Input['ProvisionerOptionsSshArgs']]):
        pulumi.set(self, "ssh", value)

    @property
    @pulumi.getter
    def x509(self) -> Optional[pulumi.Input['ProvisionerOptionsX509Args']]:
        """
        Options that apply when issuing x509 certificates.
        """
        return pulumi.get(self, "x509")

    @x509.setter
    def x509(self, value: Optional[pulumi.Input['ProvisionerOptionsX509Args']]):
        pulumi.set(self, "x509", value)


if not MYPY:
    class ProvisionerOptionsSshArgsDict(TypedDict):
        template: NotRequired[pulumi.Input[str]]
        """
        A JSON representation of the SSH certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#ssh-templates).
        """
        template_data: NotRequired[pulumi.Input[str]]
        """
        A map of data that can be used by the certificate template.
        """
elif False:
    ProvisionerOptionsSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProvisionerOptionsSshArgs:
    def __init__(__self__, *,
                 template: Optional[pulumi.Input[str]] = None,
                 template_data: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] template: A JSON representation of the SSH certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#ssh-templates).
        :param pulumi.Input[str] template_data: A map of data that can be used by the certificate template.
        """
        if template is not None:
            pulumi.set(__self__, "template", template)
        if template_data is not None:
            pulumi.set(__self__, "template_data", template_data)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[str]]:
        """
        A JSON representation of the SSH certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#ssh-templates).
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter(name="templateData")
    def template_data(self) -> Optional[pulumi.Input[str]]:
        """
        A map of data that can be used by the certificate template.
        """
        return pulumi.get(self, "template_data")

    @template_data.setter
    def template_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template_data", value)


if not MYPY:
    class ProvisionerOptionsX509ArgsDict(TypedDict):
        template: NotRequired[pulumi.Input[str]]
        """
        A JSON representation of the x509 certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#x509-templates).
        """
        template_data: NotRequired[pulumi.Input[str]]
        """
        A map of data that can be used by the certificate template.
        """
elif False:
    ProvisionerOptionsX509ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProvisionerOptionsX509Args:
    def __init__(__self__, *,
                 template: Optional[pulumi.Input[str]] = None,
                 template_data: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] template: A JSON representation of the x509 certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#x509-templates).
        :param pulumi.Input[str] template_data: A map of data that can be used by the certificate template.
        """
        if template is not None:
            pulumi.set(__self__, "template", template)
        if template_data is not None:
            pulumi.set(__self__, "template_data", template_data)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[str]]:
        """
        A JSON representation of the x509 certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#x509-templates).
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter(name="templateData")
    def template_data(self) -> Optional[pulumi.Input[str]]:
        """
        A map of data that can be used by the certificate template.
        """
        return pulumi.get(self, "template_data")

    @template_data.setter
    def template_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template_data", value)


if not MYPY:
    class ProvisionerWebhookBasicAuthArgsDict(TypedDict):
        password: pulumi.Input[str]
        username: pulumi.Input[str]
elif False:
    ProvisionerWebhookBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProvisionerWebhookBasicAuthArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ProvisionerX5cArgsDict(TypedDict):
        roots: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of pem-encoded x509 certificates. Any certificate bundle that chains up to any of these roots can be used in a certificate request.
        """
elif False:
    ProvisionerX5cArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProvisionerX5cArgs:
    def __init__(__self__, *,
                 roots: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] roots: A list of pem-encoded x509 certificates. Any certificate bundle that chains up to any of these roots can be used in a certificate request.
        """
        pulumi.set(__self__, "roots", roots)

    @property
    @pulumi.getter
    def roots(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of pem-encoded x509 certificates. Any certificate bundle that chains up to any of these roots can be used in a certificate request.
        """
        return pulumi.get(self, "roots")

    @roots.setter
    def roots(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "roots", value)


if not MYPY:
    class WorkloadCertificateDataArgsDict(TypedDict):
        common_name: pulumi.Input['WorkloadCertificateDataCommonNameArgsDict']
        country: NotRequired[pulumi.Input['WorkloadCertificateDataCountryArgsDict']]
        locality: NotRequired[pulumi.Input['WorkloadCertificateDataLocalityArgsDict']]
        organization: NotRequired[pulumi.Input['WorkloadCertificateDataOrganizationArgsDict']]
        organizational_unit: NotRequired[pulumi.Input['WorkloadCertificateDataOrganizationalUnitArgsDict']]
        postal_code: NotRequired[pulumi.Input['WorkloadCertificateDataPostalCodeArgsDict']]
        province: NotRequired[pulumi.Input['WorkloadCertificateDataProvinceArgsDict']]
        sans: NotRequired[pulumi.Input['WorkloadCertificateDataSansArgsDict']]
        street_address: NotRequired[pulumi.Input['WorkloadCertificateDataStreetAddressArgsDict']]
elif False:
    WorkloadCertificateDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadCertificateDataArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input['WorkloadCertificateDataCommonNameArgs'],
                 country: Optional[pulumi.Input['WorkloadCertificateDataCountryArgs']] = None,
                 locality: Optional[pulumi.Input['WorkloadCertificateDataLocalityArgs']] = None,
                 organization: Optional[pulumi.Input['WorkloadCertificateDataOrganizationArgs']] = None,
                 organizational_unit: Optional[pulumi.Input['WorkloadCertificateDataOrganizationalUnitArgs']] = None,
                 postal_code: Optional[pulumi.Input['WorkloadCertificateDataPostalCodeArgs']] = None,
                 province: Optional[pulumi.Input['WorkloadCertificateDataProvinceArgs']] = None,
                 sans: Optional[pulumi.Input['WorkloadCertificateDataSansArgs']] = None,
                 street_address: Optional[pulumi.Input['WorkloadCertificateDataStreetAddressArgs']] = None):
        pulumi.set(__self__, "common_name", common_name)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if locality is not None:
            pulumi.set(__self__, "locality", locality)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if organizational_unit is not None:
            pulumi.set(__self__, "organizational_unit", organizational_unit)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if province is not None:
            pulumi.set(__self__, "province", province)
        if sans is not None:
            pulumi.set(__self__, "sans", sans)
        if street_address is not None:
            pulumi.set(__self__, "street_address", street_address)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input['WorkloadCertificateDataCommonNameArgs']:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input['WorkloadCertificateDataCommonNameArgs']):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter
    def country(self) -> Optional[pulumi.Input['WorkloadCertificateDataCountryArgs']]:
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: Optional[pulumi.Input['WorkloadCertificateDataCountryArgs']]):
        pulumi.set(self, "country", value)

    @property
    @pulumi.getter
    def locality(self) -> Optional[pulumi.Input['WorkloadCertificateDataLocalityArgs']]:
        return pulumi.get(self, "locality")

    @locality.setter
    def locality(self, value: Optional[pulumi.Input['WorkloadCertificateDataLocalityArgs']]):
        pulumi.set(self, "locality", value)

    @property
    @pulumi.getter
    def organization(self) -> Optional[pulumi.Input['WorkloadCertificateDataOrganizationArgs']]:
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: Optional[pulumi.Input['WorkloadCertificateDataOrganizationArgs']]):
        pulumi.set(self, "organization", value)

    @property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> Optional[pulumi.Input['WorkloadCertificateDataOrganizationalUnitArgs']]:
        return pulumi.get(self, "organizational_unit")

    @organizational_unit.setter
    def organizational_unit(self, value: Optional[pulumi.Input['WorkloadCertificateDataOrganizationalUnitArgs']]):
        pulumi.set(self, "organizational_unit", value)

    @property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional[pulumi.Input['WorkloadCertificateDataPostalCodeArgs']]:
        return pulumi.get(self, "postal_code")

    @postal_code.setter
    def postal_code(self, value: Optional[pulumi.Input['WorkloadCertificateDataPostalCodeArgs']]):
        pulumi.set(self, "postal_code", value)

    @property
    @pulumi.getter
    def province(self) -> Optional[pulumi.Input['WorkloadCertificateDataProvinceArgs']]:
        return pulumi.get(self, "province")

    @province.setter
    def province(self, value: Optional[pulumi.Input['WorkloadCertificateDataProvinceArgs']]):
        pulumi.set(self, "province", value)

    @property
    @pulumi.getter
    def sans(self) -> Optional[pulumi.Input['WorkloadCertificateDataSansArgs']]:
        return pulumi.get(self, "sans")

    @sans.setter
    def sans(self, value: Optional[pulumi.Input['WorkloadCertificateDataSansArgs']]):
        pulumi.set(self, "sans", value)

    @property
    @pulumi.getter(name="streetAddress")
    def street_address(self) -> Optional[pulumi.Input['WorkloadCertificateDataStreetAddressArgs']]:
        return pulumi.get(self, "street_address")

    @street_address.setter
    def street_address(self, value: Optional[pulumi.Input['WorkloadCertificateDataStreetAddressArgs']]):
        pulumi.set(self, "street_address", value)


if not MYPY:
    class WorkloadCertificateDataCommonNameArgsDict(TypedDict):
        device_metadata: NotRequired[pulumi.Input[str]]
        static: NotRequired[pulumi.Input[str]]
elif False:
    WorkloadCertificateDataCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadCertificateDataCommonNameArgs:
    def __init__(__self__, *,
                 device_metadata: Optional[pulumi.Input[str]] = None,
                 static: Optional[pulumi.Input[str]] = None):
        if device_metadata is not None:
            pulumi.set(__self__, "device_metadata", device_metadata)
        if static is not None:
            pulumi.set(__self__, "static", static)

    @property
    @pulumi.getter(name="deviceMetadata")
    def device_metadata(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "device_metadata")

    @device_metadata.setter
    def device_metadata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_metadata", value)

    @property
    @pulumi.getter
    def static(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "static")

    @static.setter
    def static(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "static", value)


if not MYPY:
    class WorkloadCertificateDataCountryArgsDict(TypedDict):
        device_metadatas: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        statics: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WorkloadCertificateDataCountryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadCertificateDataCountryArgs:
    def __init__(__self__, *,
                 device_metadatas: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 statics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "device_metadatas")

    @device_metadatas.setter
    def device_metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_metadatas", value)

    @property
    @pulumi.getter
    def statics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "statics")

    @statics.setter
    def statics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "statics", value)


if not MYPY:
    class WorkloadCertificateDataLocalityArgsDict(TypedDict):
        device_metadatas: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        statics: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WorkloadCertificateDataLocalityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadCertificateDataLocalityArgs:
    def __init__(__self__, *,
                 device_metadatas: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 statics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "device_metadatas")

    @device_metadatas.setter
    def device_metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_metadatas", value)

    @property
    @pulumi.getter
    def statics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "statics")

    @statics.setter
    def statics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "statics", value)


if not MYPY:
    class WorkloadCertificateDataOrganizationArgsDict(TypedDict):
        device_metadatas: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        statics: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WorkloadCertificateDataOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadCertificateDataOrganizationArgs:
    def __init__(__self__, *,
                 device_metadatas: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 statics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "device_metadatas")

    @device_metadatas.setter
    def device_metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_metadatas", value)

    @property
    @pulumi.getter
    def statics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "statics")

    @statics.setter
    def statics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "statics", value)


if not MYPY:
    class WorkloadCertificateDataOrganizationalUnitArgsDict(TypedDict):
        device_metadatas: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        statics: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WorkloadCertificateDataOrganizationalUnitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadCertificateDataOrganizationalUnitArgs:
    def __init__(__self__, *,
                 device_metadatas: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 statics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "device_metadatas")

    @device_metadatas.setter
    def device_metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_metadatas", value)

    @property
    @pulumi.getter
    def statics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "statics")

    @statics.setter
    def statics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "statics", value)


if not MYPY:
    class WorkloadCertificateDataPostalCodeArgsDict(TypedDict):
        device_metadatas: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        statics: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WorkloadCertificateDataPostalCodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadCertificateDataPostalCodeArgs:
    def __init__(__self__, *,
                 device_metadatas: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 statics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "device_metadatas")

    @device_metadatas.setter
    def device_metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_metadatas", value)

    @property
    @pulumi.getter
    def statics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "statics")

    @statics.setter
    def statics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "statics", value)


if not MYPY:
    class WorkloadCertificateDataProvinceArgsDict(TypedDict):
        device_metadatas: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        statics: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WorkloadCertificateDataProvinceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadCertificateDataProvinceArgs:
    def __init__(__self__, *,
                 device_metadatas: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 statics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "device_metadatas")

    @device_metadatas.setter
    def device_metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_metadatas", value)

    @property
    @pulumi.getter
    def statics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "statics")

    @statics.setter
    def statics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "statics", value)


if not MYPY:
    class WorkloadCertificateDataSansArgsDict(TypedDict):
        device_metadatas: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        statics: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WorkloadCertificateDataSansArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadCertificateDataSansArgs:
    def __init__(__self__, *,
                 device_metadatas: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 statics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "device_metadatas")

    @device_metadatas.setter
    def device_metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_metadatas", value)

    @property
    @pulumi.getter
    def statics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "statics")

    @statics.setter
    def statics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "statics", value)


if not MYPY:
    class WorkloadCertificateDataStreetAddressArgsDict(TypedDict):
        device_metadatas: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        statics: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WorkloadCertificateDataStreetAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadCertificateDataStreetAddressArgs:
    def __init__(__self__, *,
                 device_metadatas: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 statics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "device_metadatas")

    @device_metadatas.setter
    def device_metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_metadatas", value)

    @property
    @pulumi.getter
    def statics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "statics")

    @statics.setter
    def statics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "statics", value)


if not MYPY:
    class WorkloadCertificateInfoArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The type of certificate. Allowed values: `X509` `SSH_USER` `SSH_HOST`
        """
        crt_file: NotRequired[pulumi.Input[str]]
        """
        The filepath where the certificate is to be stored.
        """
        duration: NotRequired[pulumi.Input[str]]
        """
        The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        gid: NotRequired[pulumi.Input[float]]
        """
        GID of the files where the certificate is stored.
        """
        key_file: NotRequired[pulumi.Input[str]]
        """
        The filepath where the key is to be stored.
        """
        mode: NotRequired[pulumi.Input[float]]
        """
        Permission bits of the files where the certificate is stored.
        """
        root_file: NotRequired[pulumi.Input[str]]
        """
        The filepath where the root certificate is to be stored.
        """
        uid: NotRequired[pulumi.Input[float]]
        """
        UID of the files where the certificate is stored.
        """
elif False:
    WorkloadCertificateInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadCertificateInfoArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 crt_file: Optional[pulumi.Input[str]] = None,
                 duration: Optional[pulumi.Input[str]] = None,
                 gid: Optional[pulumi.Input[float]] = None,
                 key_file: Optional[pulumi.Input[str]] = None,
                 mode: Optional[pulumi.Input[float]] = None,
                 root_file: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] type: The type of certificate. Allowed values: `X509` `SSH_USER` `SSH_HOST`
        :param pulumi.Input[str] crt_file: The filepath where the certificate is to be stored.
        :param pulumi.Input[str] duration: The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param pulumi.Input[float] gid: GID of the files where the certificate is stored.
        :param pulumi.Input[str] key_file: The filepath where the key is to be stored.
        :param pulumi.Input[float] mode: Permission bits of the files where the certificate is stored.
        :param pulumi.Input[str] root_file: The filepath where the root certificate is to be stored.
        :param pulumi.Input[float] uid: UID of the files where the certificate is stored.
        """
        pulumi.set(__self__, "type", type)
        if crt_file is not None:
            pulumi.set(__self__, "crt_file", crt_file)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if gid is not None:
            pulumi.set(__self__, "gid", gid)
        if key_file is not None:
            pulumi.set(__self__, "key_file", key_file)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if root_file is not None:
            pulumi.set(__self__, "root_file", root_file)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of certificate. Allowed values: `X509` `SSH_USER` `SSH_HOST`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="crtFile")
    def crt_file(self) -> Optional[pulumi.Input[str]]:
        """
        The filepath where the certificate is to be stored.
        """
        return pulumi.get(self, "crt_file")

    @crt_file.setter
    def crt_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "crt_file", value)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[str]]:
        """
        The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter
    def gid(self) -> Optional[pulumi.Input[float]]:
        """
        GID of the files where the certificate is stored.
        """
        return pulumi.get(self, "gid")

    @gid.setter
    def gid(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "gid", value)

    @property
    @pulumi.getter(name="keyFile")
    def key_file(self) -> Optional[pulumi.Input[str]]:
        """
        The filepath where the key is to be stored.
        """
        return pulumi.get(self, "key_file")

    @key_file.setter
    def key_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_file", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[float]]:
        """
        Permission bits of the files where the certificate is stored.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="rootFile")
    def root_file(self) -> Optional[pulumi.Input[str]]:
        """
        The filepath where the root certificate is to be stored.
        """
        return pulumi.get(self, "root_file")

    @root_file.setter
    def root_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "root_file", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[float]]:
        """
        UID of the files where the certificate is stored.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class WorkloadHooksArgsDict(TypedDict):
        renew: NotRequired[pulumi.Input['WorkloadHooksRenewArgsDict']]
        """
        A list of commands to run before and after a certificate is granted.
        """
        sign: NotRequired[pulumi.Input['WorkloadHooksSignArgsDict']]
        """
        A list of commands to run before and after a certificate is granted.
        """
elif False:
    WorkloadHooksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadHooksArgs:
    def __init__(__self__, *,
                 renew: Optional[pulumi.Input['WorkloadHooksRenewArgs']] = None,
                 sign: Optional[pulumi.Input['WorkloadHooksSignArgs']] = None):
        """
        :param pulumi.Input['WorkloadHooksRenewArgs'] renew: A list of commands to run before and after a certificate is granted.
        :param pulumi.Input['WorkloadHooksSignArgs'] sign: A list of commands to run before and after a certificate is granted.
        """
        if renew is not None:
            pulumi.set(__self__, "renew", renew)
        if sign is not None:
            pulumi.set(__self__, "sign", sign)

    @property
    @pulumi.getter
    def renew(self) -> Optional[pulumi.Input['WorkloadHooksRenewArgs']]:
        """
        A list of commands to run before and after a certificate is granted.
        """
        return pulumi.get(self, "renew")

    @renew.setter
    def renew(self, value: Optional[pulumi.Input['WorkloadHooksRenewArgs']]):
        pulumi.set(self, "renew", value)

    @property
    @pulumi.getter
    def sign(self) -> Optional[pulumi.Input['WorkloadHooksSignArgs']]:
        """
        A list of commands to run before and after a certificate is granted.
        """
        return pulumi.get(self, "sign")

    @sign.setter
    def sign(self, value: Optional[pulumi.Input['WorkloadHooksSignArgs']]):
        pulumi.set(self, "sign", value)


if not MYPY:
    class WorkloadHooksRenewArgsDict(TypedDict):
        afters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of commands to run after the operation.
        """
        befores: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of commands to run before the operation.
        """
        on_errors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of commands to run when the operation fails.
        """
        shell: NotRequired[pulumi.Input[str]]
        """
        The shell to use to execute the commands.
        """
elif False:
    WorkloadHooksRenewArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadHooksRenewArgs:
    def __init__(__self__, *,
                 afters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 befores: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 on_errors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 shell: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] afters: List of commands to run after the operation.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] befores: List of commands to run before the operation.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] on_errors: List of commands to run when the operation fails.
        :param pulumi.Input[str] shell: The shell to use to execute the commands.
        """
        if afters is not None:
            pulumi.set(__self__, "afters", afters)
        if befores is not None:
            pulumi.set(__self__, "befores", befores)
        if on_errors is not None:
            pulumi.set(__self__, "on_errors", on_errors)
        if shell is not None:
            pulumi.set(__self__, "shell", shell)

    @property
    @pulumi.getter
    def afters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of commands to run after the operation.
        """
        return pulumi.get(self, "afters")

    @afters.setter
    def afters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "afters", value)

    @property
    @pulumi.getter
    def befores(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of commands to run before the operation.
        """
        return pulumi.get(self, "befores")

    @befores.setter
    def befores(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "befores", value)

    @property
    @pulumi.getter(name="onErrors")
    def on_errors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of commands to run when the operation fails.
        """
        return pulumi.get(self, "on_errors")

    @on_errors.setter
    def on_errors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "on_errors", value)

    @property
    @pulumi.getter
    def shell(self) -> Optional[pulumi.Input[str]]:
        """
        The shell to use to execute the commands.
        """
        return pulumi.get(self, "shell")

    @shell.setter
    def shell(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shell", value)


if not MYPY:
    class WorkloadHooksSignArgsDict(TypedDict):
        afters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of commands to run after the operation.
        """
        befores: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of commands to run before the operation.
        """
        on_errors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of commands to run when the operation fails.
        """
        shell: NotRequired[pulumi.Input[str]]
        """
        The shell to use to execute the commands.
        """
elif False:
    WorkloadHooksSignArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadHooksSignArgs:
    def __init__(__self__, *,
                 afters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 befores: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 on_errors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 shell: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] afters: List of commands to run after the operation.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] befores: List of commands to run before the operation.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] on_errors: List of commands to run when the operation fails.
        :param pulumi.Input[str] shell: The shell to use to execute the commands.
        """
        if afters is not None:
            pulumi.set(__self__, "afters", afters)
        if befores is not None:
            pulumi.set(__self__, "befores", befores)
        if on_errors is not None:
            pulumi.set(__self__, "on_errors", on_errors)
        if shell is not None:
            pulumi.set(__self__, "shell", shell)

    @property
    @pulumi.getter
    def afters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of commands to run after the operation.
        """
        return pulumi.get(self, "afters")

    @afters.setter
    def afters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "afters", value)

    @property
    @pulumi.getter
    def befores(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of commands to run before the operation.
        """
        return pulumi.get(self, "befores")

    @befores.setter
    def befores(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "befores", value)

    @property
    @pulumi.getter(name="onErrors")
    def on_errors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of commands to run when the operation fails.
        """
        return pulumi.get(self, "on_errors")

    @on_errors.setter
    def on_errors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "on_errors", value)

    @property
    @pulumi.getter
    def shell(self) -> Optional[pulumi.Input[str]]:
        """
        The shell to use to execute the commands.
        """
        return pulumi.get(self, "shell")

    @shell.setter
    def shell(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shell", value)


if not MYPY:
    class WorkloadKeyInfoArgsDict(TypedDict):
        format: pulumi.Input[str]
        """
        The format used to encode the private key. For X509 keys the default format is PKCS#8. The classic format is PKCS#1 for RSA keys, SEC 1 for ECDSA keys, and PKCS#8 for ED25519 keys. For SSH keys the default format is always the OPENSSH format. When a hardware module is used to store the keys the default will be a JSON representation of the key, except on Linux where tss2 will be used. Allowed values: `DEFAULT` `PKCS8` `OPENSSH` `TSS2` `CLASSIC`
        """
        type: pulumi.Input[str]
        """
        The key type used. The current DEFAULT type is ECDSA_P256. Allowed values: `DEFAULT` `ECDSA_P256` `ECDSA_P384` `ECDSA_P521` `RSA_2048` `RSA_3072` `RSA_4096` `ED25519`
        """
        protection: NotRequired[pulumi.Input[str]]
        """
        Whether to use a hardware module to store the private key for a workload certificate. If set to `NONE` no hardware module will be used. If set to `DEFAULT` a hardware module will only be used with format `TSS2`. `HARDWARE_WITH_FALLBACK` can only be used with the key format `DEFAULT`. Allowed values: `DEFAULT` `NONE` `HARDWARE` `HARDWARE_WITH_FALLBACK` `HARDWARE_ATTESTED`
        """
        pub_file: NotRequired[pulumi.Input[str]]
        """
        A CSR or SSH public key to use instead of generating one.
        """
elif False:
    WorkloadKeyInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadKeyInfoArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 type: pulumi.Input[str],
                 protection: Optional[pulumi.Input[str]] = None,
                 pub_file: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] format: The format used to encode the private key. For X509 keys the default format is PKCS#8. The classic format is PKCS#1 for RSA keys, SEC 1 for ECDSA keys, and PKCS#8 for ED25519 keys. For SSH keys the default format is always the OPENSSH format. When a hardware module is used to store the keys the default will be a JSON representation of the key, except on Linux where tss2 will be used. Allowed values: `DEFAULT` `PKCS8` `OPENSSH` `TSS2` `CLASSIC`
        :param pulumi.Input[str] type: The key type used. The current DEFAULT type is ECDSA_P256. Allowed values: `DEFAULT` `ECDSA_P256` `ECDSA_P384` `ECDSA_P521` `RSA_2048` `RSA_3072` `RSA_4096` `ED25519`
        :param pulumi.Input[str] protection: Whether to use a hardware module to store the private key for a workload certificate. If set to `NONE` no hardware module will be used. If set to `DEFAULT` a hardware module will only be used with format `TSS2`. `HARDWARE_WITH_FALLBACK` can only be used with the key format `DEFAULT`. Allowed values: `DEFAULT` `NONE` `HARDWARE` `HARDWARE_WITH_FALLBACK` `HARDWARE_ATTESTED`
        :param pulumi.Input[str] pub_file: A CSR or SSH public key to use instead of generating one.
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "type", type)
        if protection is not None:
            pulumi.set(__self__, "protection", protection)
        if pub_file is not None:
            pulumi.set(__self__, "pub_file", pub_file)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        """
        The format used to encode the private key. For X509 keys the default format is PKCS#8. The classic format is PKCS#1 for RSA keys, SEC 1 for ECDSA keys, and PKCS#8 for ED25519 keys. For SSH keys the default format is always the OPENSSH format. When a hardware module is used to store the keys the default will be a JSON representation of the key, except on Linux where tss2 will be used. Allowed values: `DEFAULT` `PKCS8` `OPENSSH` `TSS2` `CLASSIC`
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The key type used. The current DEFAULT type is ECDSA_P256. Allowed values: `DEFAULT` `ECDSA_P256` `ECDSA_P384` `ECDSA_P521` `RSA_2048` `RSA_3072` `RSA_4096` `ED25519`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def protection(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to use a hardware module to store the private key for a workload certificate. If set to `NONE` no hardware module will be used. If set to `DEFAULT` a hardware module will only be used with format `TSS2`. `HARDWARE_WITH_FALLBACK` can only be used with the key format `DEFAULT`. Allowed values: `DEFAULT` `NONE` `HARDWARE` `HARDWARE_WITH_FALLBACK` `HARDWARE_ATTESTED`
        """
        return pulumi.get(self, "protection")

    @protection.setter
    def protection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protection", value)

    @property
    @pulumi.getter(name="pubFile")
    def pub_file(self) -> Optional[pulumi.Input[str]]:
        """
        A CSR or SSH public key to use instead of generating one.
        """
        return pulumi.get(self, "pub_file")

    @pub_file.setter
    def pub_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pub_file", value)


if not MYPY:
    class WorkloadReloadInfoArgsDict(TypedDict):
        method: pulumi.Input[str]
        """
        Ways an endpoint can reload a certificate. `AUTOMATIC` means the process is able to detect and reload new certificates automatically. `CUSTOM` means a custom command must be run to trigger the workload to reload the certificates. `SIGNAL` will configure the agent to send a signal to the process in `pidFile`. `DBUS` will use the systemd system bus to issue a `try-reload-or-restart` job for unit specified by `unitName`. `PLATFORM` uses a method specific to the operating system. Allowed values: `AUTOMATIC` `CUSTOM` `SIGNAL` `DBUS` `PLATFORM`
        """
        pid_file: NotRequired[pulumi.Input[str]]
        """
        File that holds the pid of the process to signal. Required when method is SIGNAL.
        """
        signal: NotRequired[pulumi.Input[float]]
        """
        The signal to send to a process when a certificate should be reloaded. Required when method is SIGNAL.
        """
        unit_name: NotRequired[pulumi.Input[str]]
        """
        The systemd unit name to reload when a certificate should be reloaded. Required when method is DBUS.
        """
elif False:
    WorkloadReloadInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadReloadInfoArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[str],
                 pid_file: Optional[pulumi.Input[str]] = None,
                 signal: Optional[pulumi.Input[float]] = None,
                 unit_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] method: Ways an endpoint can reload a certificate. `AUTOMATIC` means the process is able to detect and reload new certificates automatically. `CUSTOM` means a custom command must be run to trigger the workload to reload the certificates. `SIGNAL` will configure the agent to send a signal to the process in `pidFile`. `DBUS` will use the systemd system bus to issue a `try-reload-or-restart` job for unit specified by `unitName`. `PLATFORM` uses a method specific to the operating system. Allowed values: `AUTOMATIC` `CUSTOM` `SIGNAL` `DBUS` `PLATFORM`
        :param pulumi.Input[str] pid_file: File that holds the pid of the process to signal. Required when method is SIGNAL.
        :param pulumi.Input[float] signal: The signal to send to a process when a certificate should be reloaded. Required when method is SIGNAL.
        :param pulumi.Input[str] unit_name: The systemd unit name to reload when a certificate should be reloaded. Required when method is DBUS.
        """
        pulumi.set(__self__, "method", method)
        if pid_file is not None:
            pulumi.set(__self__, "pid_file", pid_file)
        if signal is not None:
            pulumi.set(__self__, "signal", signal)
        if unit_name is not None:
            pulumi.set(__self__, "unit_name", unit_name)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[str]:
        """
        Ways an endpoint can reload a certificate. `AUTOMATIC` means the process is able to detect and reload new certificates automatically. `CUSTOM` means a custom command must be run to trigger the workload to reload the certificates. `SIGNAL` will configure the agent to send a signal to the process in `pidFile`. `DBUS` will use the systemd system bus to issue a `try-reload-or-restart` job for unit specified by `unitName`. `PLATFORM` uses a method specific to the operating system. Allowed values: `AUTOMATIC` `CUSTOM` `SIGNAL` `DBUS` `PLATFORM`
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="pidFile")
    def pid_file(self) -> Optional[pulumi.Input[str]]:
        """
        File that holds the pid of the process to signal. Required when method is SIGNAL.
        """
        return pulumi.get(self, "pid_file")

    @pid_file.setter
    def pid_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pid_file", value)

    @property
    @pulumi.getter
    def signal(self) -> Optional[pulumi.Input[float]]:
        """
        The signal to send to a process when a certificate should be reloaded. Required when method is SIGNAL.
        """
        return pulumi.get(self, "signal")

    @signal.setter
    def signal(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "signal", value)

    @property
    @pulumi.getter(name="unitName")
    def unit_name(self) -> Optional[pulumi.Input[str]]:
        """
        The systemd unit name to reload when a certificate should be reloaded. Required when method is DBUS.
        """
        return pulumi.get(self, "unit_name")

    @unit_name.setter
    def unit_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unit_name", value)


if not MYPY:
    class GetDeviceCollectionAccountCertificateDataArgsDict(TypedDict):
        common_name: NotRequired['GetDeviceCollectionAccountCertificateDataCommonNameArgsDict']
        country: NotRequired['GetDeviceCollectionAccountCertificateDataCountryArgsDict']
        locality: NotRequired['GetDeviceCollectionAccountCertificateDataLocalityArgsDict']
        organization: NotRequired['GetDeviceCollectionAccountCertificateDataOrganizationArgsDict']
        organizational_unit: NotRequired['GetDeviceCollectionAccountCertificateDataOrganizationalUnitArgsDict']
        postal_code: NotRequired['GetDeviceCollectionAccountCertificateDataPostalCodeArgsDict']
        province: NotRequired['GetDeviceCollectionAccountCertificateDataProvinceArgsDict']
        sans: NotRequired['GetDeviceCollectionAccountCertificateDataSansArgsDict']
        street_address: NotRequired['GetDeviceCollectionAccountCertificateDataStreetAddressArgsDict']
elif False:
    GetDeviceCollectionAccountCertificateDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeviceCollectionAccountCertificateDataArgs:
    def __init__(__self__, *,
                 common_name: Optional['GetDeviceCollectionAccountCertificateDataCommonNameArgs'] = None,
                 country: Optional['GetDeviceCollectionAccountCertificateDataCountryArgs'] = None,
                 locality: Optional['GetDeviceCollectionAccountCertificateDataLocalityArgs'] = None,
                 organization: Optional['GetDeviceCollectionAccountCertificateDataOrganizationArgs'] = None,
                 organizational_unit: Optional['GetDeviceCollectionAccountCertificateDataOrganizationalUnitArgs'] = None,
                 postal_code: Optional['GetDeviceCollectionAccountCertificateDataPostalCodeArgs'] = None,
                 province: Optional['GetDeviceCollectionAccountCertificateDataProvinceArgs'] = None,
                 sans: Optional['GetDeviceCollectionAccountCertificateDataSansArgs'] = None,
                 street_address: Optional['GetDeviceCollectionAccountCertificateDataStreetAddressArgs'] = None):
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if locality is not None:
            pulumi.set(__self__, "locality", locality)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if organizational_unit is not None:
            pulumi.set(__self__, "organizational_unit", organizational_unit)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if province is not None:
            pulumi.set(__self__, "province", province)
        if sans is not None:
            pulumi.set(__self__, "sans", sans)
        if street_address is not None:
            pulumi.set(__self__, "street_address", street_address)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional['GetDeviceCollectionAccountCertificateDataCommonNameArgs']:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional['GetDeviceCollectionAccountCertificateDataCommonNameArgs']):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter
    def country(self) -> Optional['GetDeviceCollectionAccountCertificateDataCountryArgs']:
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: Optional['GetDeviceCollectionAccountCertificateDataCountryArgs']):
        pulumi.set(self, "country", value)

    @property
    @pulumi.getter
    def locality(self) -> Optional['GetDeviceCollectionAccountCertificateDataLocalityArgs']:
        return pulumi.get(self, "locality")

    @locality.setter
    def locality(self, value: Optional['GetDeviceCollectionAccountCertificateDataLocalityArgs']):
        pulumi.set(self, "locality", value)

    @property
    @pulumi.getter
    def organization(self) -> Optional['GetDeviceCollectionAccountCertificateDataOrganizationArgs']:
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: Optional['GetDeviceCollectionAccountCertificateDataOrganizationArgs']):
        pulumi.set(self, "organization", value)

    @property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> Optional['GetDeviceCollectionAccountCertificateDataOrganizationalUnitArgs']:
        return pulumi.get(self, "organizational_unit")

    @organizational_unit.setter
    def organizational_unit(self, value: Optional['GetDeviceCollectionAccountCertificateDataOrganizationalUnitArgs']):
        pulumi.set(self, "organizational_unit", value)

    @property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional['GetDeviceCollectionAccountCertificateDataPostalCodeArgs']:
        return pulumi.get(self, "postal_code")

    @postal_code.setter
    def postal_code(self, value: Optional['GetDeviceCollectionAccountCertificateDataPostalCodeArgs']):
        pulumi.set(self, "postal_code", value)

    @property
    @pulumi.getter
    def province(self) -> Optional['GetDeviceCollectionAccountCertificateDataProvinceArgs']:
        return pulumi.get(self, "province")

    @province.setter
    def province(self, value: Optional['GetDeviceCollectionAccountCertificateDataProvinceArgs']):
        pulumi.set(self, "province", value)

    @property
    @pulumi.getter
    def sans(self) -> Optional['GetDeviceCollectionAccountCertificateDataSansArgs']:
        return pulumi.get(self, "sans")

    @sans.setter
    def sans(self, value: Optional['GetDeviceCollectionAccountCertificateDataSansArgs']):
        pulumi.set(self, "sans", value)

    @property
    @pulumi.getter(name="streetAddress")
    def street_address(self) -> Optional['GetDeviceCollectionAccountCertificateDataStreetAddressArgs']:
        return pulumi.get(self, "street_address")

    @street_address.setter
    def street_address(self, value: Optional['GetDeviceCollectionAccountCertificateDataStreetAddressArgs']):
        pulumi.set(self, "street_address", value)


if not MYPY:
    class GetDeviceCollectionAccountCertificateDataCommonNameArgsDict(TypedDict):
        device_metadata: NotRequired[str]
        static: NotRequired[str]
elif False:
    GetDeviceCollectionAccountCertificateDataCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeviceCollectionAccountCertificateDataCommonNameArgs:
    def __init__(__self__, *,
                 device_metadata: Optional[str] = None,
                 static: Optional[str] = None):
        if device_metadata is not None:
            pulumi.set(__self__, "device_metadata", device_metadata)
        if static is not None:
            pulumi.set(__self__, "static", static)

    @property
    @pulumi.getter(name="deviceMetadata")
    def device_metadata(self) -> Optional[str]:
        return pulumi.get(self, "device_metadata")

    @device_metadata.setter
    def device_metadata(self, value: Optional[str]):
        pulumi.set(self, "device_metadata", value)

    @property
    @pulumi.getter
    def static(self) -> Optional[str]:
        return pulumi.get(self, "static")

    @static.setter
    def static(self, value: Optional[str]):
        pulumi.set(self, "static", value)


if not MYPY:
    class GetDeviceCollectionAccountCertificateDataCountryArgsDict(TypedDict):
        device_metadatas: NotRequired[Sequence[str]]
        statics: NotRequired[Sequence[str]]
elif False:
    GetDeviceCollectionAccountCertificateDataCountryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeviceCollectionAccountCertificateDataCountryArgs:
    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @device_metadatas.setter
    def device_metadatas(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "device_metadatas", value)

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")

    @statics.setter
    def statics(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "statics", value)


if not MYPY:
    class GetDeviceCollectionAccountCertificateDataLocalityArgsDict(TypedDict):
        device_metadatas: NotRequired[Sequence[str]]
        statics: NotRequired[Sequence[str]]
elif False:
    GetDeviceCollectionAccountCertificateDataLocalityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeviceCollectionAccountCertificateDataLocalityArgs:
    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @device_metadatas.setter
    def device_metadatas(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "device_metadatas", value)

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")

    @statics.setter
    def statics(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "statics", value)


if not MYPY:
    class GetDeviceCollectionAccountCertificateDataOrganizationArgsDict(TypedDict):
        device_metadatas: NotRequired[Sequence[str]]
        statics: NotRequired[Sequence[str]]
elif False:
    GetDeviceCollectionAccountCertificateDataOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeviceCollectionAccountCertificateDataOrganizationArgs:
    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @device_metadatas.setter
    def device_metadatas(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "device_metadatas", value)

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")

    @statics.setter
    def statics(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "statics", value)


if not MYPY:
    class GetDeviceCollectionAccountCertificateDataOrganizationalUnitArgsDict(TypedDict):
        device_metadatas: NotRequired[Sequence[str]]
        statics: NotRequired[Sequence[str]]
elif False:
    GetDeviceCollectionAccountCertificateDataOrganizationalUnitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeviceCollectionAccountCertificateDataOrganizationalUnitArgs:
    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @device_metadatas.setter
    def device_metadatas(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "device_metadatas", value)

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")

    @statics.setter
    def statics(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "statics", value)


if not MYPY:
    class GetDeviceCollectionAccountCertificateDataPostalCodeArgsDict(TypedDict):
        device_metadatas: NotRequired[Sequence[str]]
        statics: NotRequired[Sequence[str]]
elif False:
    GetDeviceCollectionAccountCertificateDataPostalCodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeviceCollectionAccountCertificateDataPostalCodeArgs:
    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @device_metadatas.setter
    def device_metadatas(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "device_metadatas", value)

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")

    @statics.setter
    def statics(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "statics", value)


if not MYPY:
    class GetDeviceCollectionAccountCertificateDataProvinceArgsDict(TypedDict):
        device_metadatas: NotRequired[Sequence[str]]
        statics: NotRequired[Sequence[str]]
elif False:
    GetDeviceCollectionAccountCertificateDataProvinceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeviceCollectionAccountCertificateDataProvinceArgs:
    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @device_metadatas.setter
    def device_metadatas(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "device_metadatas", value)

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")

    @statics.setter
    def statics(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "statics", value)


if not MYPY:
    class GetDeviceCollectionAccountCertificateDataSansArgsDict(TypedDict):
        device_metadatas: NotRequired[Sequence[str]]
        statics: NotRequired[Sequence[str]]
elif False:
    GetDeviceCollectionAccountCertificateDataSansArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeviceCollectionAccountCertificateDataSansArgs:
    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @device_metadatas.setter
    def device_metadatas(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "device_metadatas", value)

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")

    @statics.setter
    def statics(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "statics", value)


if not MYPY:
    class GetDeviceCollectionAccountCertificateDataStreetAddressArgsDict(TypedDict):
        device_metadatas: NotRequired[Sequence[str]]
        statics: NotRequired[Sequence[str]]
elif False:
    GetDeviceCollectionAccountCertificateDataStreetAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeviceCollectionAccountCertificateDataStreetAddressArgs:
    def __init__(__self__, *,
                 device_metadatas: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence[str]] = None):
        if device_metadatas is not None:
            pulumi.set(__self__, "device_metadatas", device_metadatas)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter(name="deviceMetadatas")
    def device_metadatas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "device_metadatas")

    @device_metadatas.setter
    def device_metadatas(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "device_metadatas", value)

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "statics")

    @statics.setter
    def statics(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "statics", value)


if not MYPY:
    class GetDeviceCollectionAccountCertificateInfoArgsDict(TypedDict):
        crt_file: NotRequired[str]
        """
        The filepath where the certificate is to be stored.
        """
        duration: NotRequired[str]
        """
        The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        gid: NotRequired[float]
        """
        GID of the files where the certificate is stored.
        """
        key_file: NotRequired[str]
        """
        The filepath where the key is to be stored.
        """
        mode: NotRequired[float]
        """
        Permission bits of the files where the certificate is stored.
        """
        root_file: NotRequired[str]
        """
        The filepath where the root certificate is to be stored.
        """
        type: NotRequired[str]
        """
        The type of certificate. Allowed values: `X509` `SSH_USER` `SSH_HOST`
        """
        uid: NotRequired[float]
        """
        UID of the files where the certificate is stored.
        """
elif False:
    GetDeviceCollectionAccountCertificateInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeviceCollectionAccountCertificateInfoArgs:
    def __init__(__self__, *,
                 crt_file: Optional[str] = None,
                 duration: Optional[str] = None,
                 gid: Optional[float] = None,
                 key_file: Optional[str] = None,
                 mode: Optional[float] = None,
                 root_file: Optional[str] = None,
                 type: Optional[str] = None,
                 uid: Optional[float] = None):
        """
        :param str crt_file: The filepath where the certificate is to be stored.
        :param str duration: The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        :param float gid: GID of the files where the certificate is stored.
        :param str key_file: The filepath where the key is to be stored.
        :param float mode: Permission bits of the files where the certificate is stored.
        :param str root_file: The filepath where the root certificate is to be stored.
        :param str type: The type of certificate. Allowed values: `X509` `SSH_USER` `SSH_HOST`
        :param float uid: UID of the files where the certificate is stored.
        """
        if crt_file is not None:
            pulumi.set(__self__, "crt_file", crt_file)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if gid is not None:
            pulumi.set(__self__, "gid", gid)
        if key_file is not None:
            pulumi.set(__self__, "key_file", key_file)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if root_file is not None:
            pulumi.set(__self__, "root_file", root_file)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="crtFile")
    def crt_file(self) -> Optional[str]:
        """
        The filepath where the certificate is to be stored.
        """
        return pulumi.get(self, "crt_file")

    @crt_file.setter
    def crt_file(self, value: Optional[str]):
        pulumi.set(self, "crt_file", value)

    @property
    @pulumi.getter
    def duration(self) -> Optional[str]:
        """
        The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[str]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter
    def gid(self) -> Optional[float]:
        """
        GID of the files where the certificate is stored.
        """
        return pulumi.get(self, "gid")

    @gid.setter
    def gid(self, value: Optional[float]):
        pulumi.set(self, "gid", value)

    @property
    @pulumi.getter(name="keyFile")
    def key_file(self) -> Optional[str]:
        """
        The filepath where the key is to be stored.
        """
        return pulumi.get(self, "key_file")

    @key_file.setter
    def key_file(self, value: Optional[str]):
        pulumi.set(self, "key_file", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[float]:
        """
        Permission bits of the files where the certificate is stored.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[float]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="rootFile")
    def root_file(self) -> Optional[str]:
        """
        The filepath where the root certificate is to be stored.
        """
        return pulumi.get(self, "root_file")

    @root_file.setter
    def root_file(self, value: Optional[str]):
        pulumi.set(self, "root_file", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of certificate. Allowed values: `X509` `SSH_USER` `SSH_HOST`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[float]:
        """
        UID of the files where the certificate is stored.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[float]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class GetDeviceCollectionAccountKeyInfoArgsDict(TypedDict):
        format: NotRequired[str]
        """
        The format used to encode the private key. For X509 keys the default format is PKCS#8. The classic format is PKCS#1 for RSA keys, SEC 1 for ECDSA keys, and PKCS#8 for ED25519 keys. For SSH keys the default format is always the OPENSSH format. When a hardware module is used to store the keys the default will be a JSON representation of the key, except on Linux where tss2 will be used. Allowed values: `DEFAULT` `PKCS8` `OPENSSH` `TSS2` `CLASSIC`
        """
        protection: NotRequired[str]
        """
        Whether to use a hardware module to store the private key for a workload certificate. If set to `NONE` no hardware module will be used. If set to `DEFAULT` a hardware module will only be used with format `TSS2`. `HARDWARE_WITH_FALLBACK` can only be used with the key format `DEFAULT`. Allowed values: `DEFAULT` `NONE` `HARDWARE` `HARDWARE_WITH_FALLBACK` `HARDWARE_ATTESTED`
        """
        pub_file: NotRequired[str]
        """
        A CSR or SSH public key to use instead of generating one.
        """
        type: NotRequired[str]
        """
        The key type used. The current DEFAULT type is ECDSA_P256. Allowed values: `DEFAULT` `ECDSA_P256` `ECDSA_P384` `ECDSA_P521` `RSA_2048` `RSA_3072` `RSA_4096` `ED25519`
        """
elif False:
    GetDeviceCollectionAccountKeyInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeviceCollectionAccountKeyInfoArgs:
    def __init__(__self__, *,
                 format: Optional[str] = None,
                 protection: Optional[str] = None,
                 pub_file: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str format: The format used to encode the private key. For X509 keys the default format is PKCS#8. The classic format is PKCS#1 for RSA keys, SEC 1 for ECDSA keys, and PKCS#8 for ED25519 keys. For SSH keys the default format is always the OPENSSH format. When a hardware module is used to store the keys the default will be a JSON representation of the key, except on Linux where tss2 will be used. Allowed values: `DEFAULT` `PKCS8` `OPENSSH` `TSS2` `CLASSIC`
        :param str protection: Whether to use a hardware module to store the private key for a workload certificate. If set to `NONE` no hardware module will be used. If set to `DEFAULT` a hardware module will only be used with format `TSS2`. `HARDWARE_WITH_FALLBACK` can only be used with the key format `DEFAULT`. Allowed values: `DEFAULT` `NONE` `HARDWARE` `HARDWARE_WITH_FALLBACK` `HARDWARE_ATTESTED`
        :param str pub_file: A CSR or SSH public key to use instead of generating one.
        :param str type: The key type used. The current DEFAULT type is ECDSA_P256. Allowed values: `DEFAULT` `ECDSA_P256` `ECDSA_P384` `ECDSA_P521` `RSA_2048` `RSA_3072` `RSA_4096` `ED25519`
        """
        if format is not None:
            pulumi.set(__self__, "format", format)
        if protection is not None:
            pulumi.set(__self__, "protection", protection)
        if pub_file is not None:
            pulumi.set(__self__, "pub_file", pub_file)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def format(self) -> Optional[str]:
        """
        The format used to encode the private key. For X509 keys the default format is PKCS#8. The classic format is PKCS#1 for RSA keys, SEC 1 for ECDSA keys, and PKCS#8 for ED25519 keys. For SSH keys the default format is always the OPENSSH format. When a hardware module is used to store the keys the default will be a JSON representation of the key, except on Linux where tss2 will be used. Allowed values: `DEFAULT` `PKCS8` `OPENSSH` `TSS2` `CLASSIC`
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def protection(self) -> Optional[str]:
        """
        Whether to use a hardware module to store the private key for a workload certificate. If set to `NONE` no hardware module will be used. If set to `DEFAULT` a hardware module will only be used with format `TSS2`. `HARDWARE_WITH_FALLBACK` can only be used with the key format `DEFAULT`. Allowed values: `DEFAULT` `NONE` `HARDWARE` `HARDWARE_WITH_FALLBACK` `HARDWARE_ATTESTED`
        """
        return pulumi.get(self, "protection")

    @protection.setter
    def protection(self, value: Optional[str]):
        pulumi.set(self, "protection", value)

    @property
    @pulumi.getter(name="pubFile")
    def pub_file(self) -> Optional[str]:
        """
        A CSR or SSH public key to use instead of generating one.
        """
        return pulumi.get(self, "pub_file")

    @pub_file.setter
    def pub_file(self, value: Optional[str]):
        pulumi.set(self, "pub_file", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The key type used. The current DEFAULT type is ECDSA_P256. Allowed values: `DEFAULT` `ECDSA_P256` `ECDSA_P384` `ECDSA_P521` `RSA_2048` `RSA_3072` `RSA_4096` `ED25519`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GetDeviceCollectionAccountReloadInfoArgsDict(TypedDict):
        method: NotRequired[str]
        """
        Ways an endpoint can reload a certificate. `AUTOMATIC` means the process is able to detect and reload new certificates automatically. `CUSTOM` means a custom command must be run to trigger the workload to reload the certificates. `SIGNAL` will configure the agent to send a signal to the process in `pidFile`. `DBUS` will use the systemd system bus to issue a `try-reload-or-restart` job for unit specified by `unitName`. `PLATFORM` uses a method specific to the operating system. Allowed values: `AUTOMATIC` `CUSTOM` `SIGNAL` `DBUS` `PLATFORM`
        """
        pid_file: NotRequired[str]
        """
        File that holds the pid of the process to signal. Required when method is SIGNAL.
        """
        signal: NotRequired[float]
        """
        The signal to send to a process when a certificate should be reloaded. Required when method is SIGNAL.
        """
        unit_name: NotRequired[str]
        """
        The systemd unit name to reload when a certificate should be reloaded. Required when method is DBUS.
        """
elif False:
    GetDeviceCollectionAccountReloadInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeviceCollectionAccountReloadInfoArgs:
    def __init__(__self__, *,
                 method: Optional[str] = None,
                 pid_file: Optional[str] = None,
                 signal: Optional[float] = None,
                 unit_name: Optional[str] = None):
        """
        :param str method: Ways an endpoint can reload a certificate. `AUTOMATIC` means the process is able to detect and reload new certificates automatically. `CUSTOM` means a custom command must be run to trigger the workload to reload the certificates. `SIGNAL` will configure the agent to send a signal to the process in `pidFile`. `DBUS` will use the systemd system bus to issue a `try-reload-or-restart` job for unit specified by `unitName`. `PLATFORM` uses a method specific to the operating system. Allowed values: `AUTOMATIC` `CUSTOM` `SIGNAL` `DBUS` `PLATFORM`
        :param str pid_file: File that holds the pid of the process to signal. Required when method is SIGNAL.
        :param float signal: The signal to send to a process when a certificate should be reloaded. Required when method is SIGNAL.
        :param str unit_name: The systemd unit name to reload when a certificate should be reloaded. Required when method is DBUS.
        """
        if method is not None:
            pulumi.set(__self__, "method", method)
        if pid_file is not None:
            pulumi.set(__self__, "pid_file", pid_file)
        if signal is not None:
            pulumi.set(__self__, "signal", signal)
        if unit_name is not None:
            pulumi.set(__self__, "unit_name", unit_name)

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        Ways an endpoint can reload a certificate. `AUTOMATIC` means the process is able to detect and reload new certificates automatically. `CUSTOM` means a custom command must be run to trigger the workload to reload the certificates. `SIGNAL` will configure the agent to send a signal to the process in `pidFile`. `DBUS` will use the systemd system bus to issue a `try-reload-or-restart` job for unit specified by `unitName`. `PLATFORM` uses a method specific to the operating system. Allowed values: `AUTOMATIC` `CUSTOM` `SIGNAL` `DBUS` `PLATFORM`
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="pidFile")
    def pid_file(self) -> Optional[str]:
        """
        File that holds the pid of the process to signal. Required when method is SIGNAL.
        """
        return pulumi.get(self, "pid_file")

    @pid_file.setter
    def pid_file(self, value: Optional[str]):
        pulumi.set(self, "pid_file", value)

    @property
    @pulumi.getter
    def signal(self) -> Optional[float]:
        """
        The signal to send to a process when a certificate should be reloaded. Required when method is SIGNAL.
        """
        return pulumi.get(self, "signal")

    @signal.setter
    def signal(self, value: Optional[float]):
        pulumi.set(self, "signal", value)

    @property
    @pulumi.getter(name="unitName")
    def unit_name(self) -> Optional[str]:
        """
        The systemd unit name to reload when a certificate should be reloaded. Required when method is DBUS.
        """
        return pulumi.get(self, "unit_name")

    @unit_name.setter
    def unit_name(self, value: Optional[str]):
        pulumi.set(self, "unit_name", value)


